<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>概率统计复习笔记（一）</title>
      <link href="/2020/05/31/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/05/31/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记（一）绪论</title>
      <link href="/2020/05/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%AA%E8%AE%BA/"/>
      <url>/2020/05/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h3><h3 id="1-2-基本术语"><a href="#1-2-基本术语" class="headerlink" title="1.2 基本术语"></a>1.2 基本术语</h3><p>（1）数据集 data set</p><p>（2）示例 instance sample</p><p>（3）属性值 attribute value</p><p>（4）样本空间 sample space</p><p>（5）分类：预测的是离散值；回归：预测的是连续值；</p><p>（6）监督学习：回归、分类；无监督学习：聚类；</p><p>（7）泛化能力 generalization</p><h3 id="1-3-假设空间"><a href="#1-3-假设空间" class="headerlink" title="1.3 假设空间"></a>1.3 假设空间</h3><p>（1）科学推理的两大手段：归纳、演绎</p><p>（2）归纳学习：从样例中学习；演绎：基本一套公理与基本规则进行推导；</p><p>（3）机械学习：对训练样本进行记忆</p><p>学习过程可以看作是一个在所有假设组成的空间中进行搜索的过程；搜索目标是找到与训练集匹配的假设；</p><h3 id="1-4-归纳偏好"><a href="#1-4-归纳偏好" class="headerlink" title="1.4 归纳偏好"></a>1.4 归纳偏好</h3><p>归纳偏好：机器学习算法在学习过程中对某种类型假设的偏好；</p><p>任何一种机器学习算法都必然有其归纳偏好，否则会被假设空间中看似在训练集上的“等效”假设所迷惑；</p><p><strong>奥卡姆剃刀：若有多个假设或者观察，则选择最简单的那一个</strong>;</p><p><strong>没有免费午餐定理：考虑两个学习算法，无论其中一个多么聪明，另一个多么笨拙，但二者的期望性能相同;</strong></p><p>（可使用分类错误率$p(x)\mathbb{I}(h(x)\ne f(x)P(h|X,\Sigma)$来度量算法的性能，$\Sigma$代表一种算法）</p><p>但事实上，NFL定理成立的重要条件是所有“问题”出现的条件与可能性均相同；</p><h3 id="习题选编"><a href="#习题选编" class="headerlink" title="习题选编"></a>习题选编</h3><p>本章1.4节在论述NFL定理时，默认使用了“分类错误率”作为性能度量来对分类器进行了评估。若换用其他度量$l$，则式（1.1）将会改写为</p><script type="math/tex; mode=display">E_{ote}(\Sigma_a|X,f) = \sum_h\sum_{x\in\chi - X}P(x)\mathcal{l}(h(x), f(x))P(h|X, \Sigma_a)</script><p>试证明，免费午餐定理依然成立。</p><h2 id="第二章-模型评估与选择"><a href="#第二章-模型评估与选择" class="headerlink" title="第二章 模型评估与选择"></a>第二章 模型评估与选择</h2><h3 id="2-1-经验误差与过拟合"><a href="#2-1-经验误差与过拟合" class="headerlink" title="2.1 经验误差与过拟合"></a>2.1 经验误差与过拟合</h3><p>（1）错误率 error rate $E=a/m$</p><p>（2）精度 accuracy  $1-a/m$</p><p>（3）训练误差 training error 在训练集上的误差</p><p>（4）泛化误差 generalization error 在新样本上的误差</p><p>（5）过拟合 overfitting：将训练样本自身的一些特点当作所有潜在样本都会具有的一般性质</p><p><strong>过拟合是机器学习面临的关键障碍。</strong>模型选择：对候选模型的泛化误差进行<strong>评估</strong>，然后选择泛化误差最小的模型。</p><h3 id="2-2-评估方法"><a href="#2-2-评估方法" class="headerlink" title="2.2 评估方法"></a>2.2 评估方法</h3><p>使用测试集测试判别能力，并将测试误差作为泛化误差的近似；</p><p>测试集应该尽量和训练集互斥；</p><p><strong>2.2.1 留出法</strong></p><p>直接将数据集$D$划分为两个互斥的集合，其中一个作为训练集，另一个作为测试集；</p><p>数据集的划分尽量保持数据分布的一致性（如采用分层采样等方法）</p><p>一般要采用若干次随机划分、重复进行试验评估后去平均值作为留出法的评估结果；</p><p><strong>2.2.2 交叉验证法</strong></p><p>通过分层采样的方式将数据集化为$k$个大小相似的互斥子集，取$k-1$个子集为训练集，剩下一个作为测试集；</p><p>留一法：使用数据只少了一个样本，则训练出的模型和用整体数据集训练出的模型比较相似，但计算开销较大；</p><p><strong>2.2.3 自助法</strong></p><p>估计偏差：由于训练样本规模不同而导致；</p><p>每次随机从数据集中抽取一个样本复制后放回，重复m次后即可得到一个包含m个数据的数据集，并将其作为训练集，剩余的未被采样的部分作为测试集。这样的结果称为包外估计（out_of_bag estimate）。其中，测试集所占比例约为：</p><script type="math/tex; mode=display">\lim_{m\rightarrow\infty}(1-\frac{1}{m})^m =  \frac{1}{e}\approx 0.368</script><p>自助法在数据集较小、难以划分有效训练/测试集时有用，但会影响数据分布；</p><p><strong>2.2.4 调参与最终模型</strong></p><p>调参 parameter tuning</p><p>现实做法：对每个参数选定一个调节范围和变化步长</p><h3 id="2-3-性能度量"><a href="#2-3-性能度量" class="headerlink" title="2.3 性能度量"></a>2.3 性能度量</h3><p><strong>回归任务常用“均方误差”</strong></p><script type="math/tex; mode=display">E(f;D) = \frac{1}{m}\sum_{i=1}^{m}(f(x_i) - y_i)^2</script><p>对于数据分布$\mathcal{D}$ 和概率密度函数$p(·)$ ，均方误差可以描述为</p><script type="math/tex; mode=display">E(f;\mathcal{D}) = \int_{x\~\mathcal{D}}(f(x)-y)^2p(x)dx</script><p><strong>分类任务的性能度量</strong></p><p>（1）错误率、精度、查准率、查全率和$F1$</p><p>真正例（TP）、假正例（FP）、真反例（TN）、假反例（FN）</p><script type="math/tex; mode=display">查准率：P=\frac{TP}{TP+FP}\\查全率：R=\frac{TP}{TP+FN}</script><p>一般而言，查准率和查全率是一组相互矛盾的度量；</p><p>根据查准率和查全率可以绘制$P-R$曲线；</p><p>若一个学习器的PR曲线完全被另一个学习器的曲线包住，则可断言或者性能优于前者；</p><p>除此外，还可比较PR曲线所包围的面积，一定程度上度量了二者双高的比例；</p><p><strong>（2）平衡点（Break Even Point）：</strong>查准率等于查全率时的取值，平衡点越大则学习器性能越好；</p><p><strong>（3）F1度量</strong></p><script type="math/tex; mode=display">F1=\frac{2\times P \times R}{P+R}</script><p>在一些任务中，对于查准率和查全率有不同的偏好，则F1度量可以进行加权调整为：</p><script type="math/tex; mode=display">F1=\frac{(1+\beta^2)\times P \times R}{\beta^2\times P + R}</script><p>对于多混淆矩阵的情形，可以考虑两种方法获取其全局性能：（1）对所有混淆矩阵的度量取平均（2）对混淆矩阵的元素取平均</p><p><strong>（4）ROC受试者工作特征（Receiver Operating Characteristic）</strong></p><script type="math/tex; mode=display">真正例率：TPR = \frac{TP}{TP+FN}\\假正例率：FPR = \frac{FP}{TN+FP}</script><p>基于TPR和FPR两组数据绘制出的曲线称为学习器的ROC曲线；</p><p>若一个学习器的曲线完全被另外一个学习器包住，则可断言后者的性能要优于前者；</p><p><strong>（5）AUC: Area Under ROC curve</strong></p><p>当两个学习器的ROC曲线出现交叉时，则考虑ROC曲线所包含的面积；AUC估计式可以表达为</p><script type="math/tex; mode=display">AUC = \frac{1}{2}\sum_{i=1}^{m-1}(x_{i+1}-x_i)\times(y_i+y_{i+1})</script><p><strong>（6）代价敏感错误率</strong></p><p>非均等代价 unequal lost的前提下会存在代价矩阵，并且用$cost_{ij}$表示上述矩阵元；</p><p>对于二分类问题，代价敏感错误率可以定义为</p><script type="math/tex; mode=display">E(f;\mathcal{D};cost)=\frac{1}{m}(\sum_{x_i\in D^+}\mathbb{I}(f(x_i)\neq y_i)*cost_{01}+\sum_{x_i\in D^-}\mathbb{I}(f(x_i)!= y_i)*cost_{10})</script><p>在非均等代价下，ROC曲线无法反映学习器的总体期望代价，而<strong>代价曲线图</strong>则可达到上述目的；</p><script type="math/tex; mode=display">横轴（正例概率代价）=\frac{p*cost_{01}}{p*cost_{01}+(1-p)*cost_{10}}\\</script><p>上述$p$代表正例的概率；</p><script type="math/tex; mode=display">纵轴（归一化代价）=\frac{FNR*p*cost_{01}+FPR*(1-p)*cost_{10}}{p*cost_{01}+(1-p)*cost_{10}}</script><p>FPR为假正例率，FNR为假反例率；</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习笔记梳理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>丑数问题</title>
      <link href="/2020/05/29/%E4%B8%91%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2020/05/29/%E4%B8%91%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="丑数问题"><a href="#丑数问题" class="headerlink" title="丑数问题"></a>丑数问题</h1><h4 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263. 丑数"></a>263. 丑数</h4><p>编写一个程序判断给定的数是否为丑数。</p><p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 6</span><br><span class="line">输出: true</span><br><span class="line">解释: 6 &#x3D; 2 × 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: true</span><br><span class="line">解释: 8 &#x3D; 2 × 2 × 2</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 14</span><br><span class="line">输出: false </span><br><span class="line">解释: 14 不是丑数，因为它包含了另外一个质因数 7。</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li><code>1</code> 是丑数。</li><li>输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]/</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(i != <span class="number">0</span>) i /= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(i != <span class="number">0</span>) i /= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i%<span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(i != <span class="number">0</span>) i /= <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> retur <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="264-丑数II"><a href="#264-丑数II" class="headerlink" title="264. 丑数II"></a>264. 丑数II</h4><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> </p><ol><li><code>1</code> 是丑数。</li><li><code>n</code> <strong>不超过</strong>1690。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">finduglynum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="313-超级丑数"><a href="#313-超级丑数" class="headerlink" title="313. 超级丑数"></a>313. 超级丑数</h4><p>编写一段程序来查找第 <code>*n*</code> 个超级丑数。</p><p>超级丑数是指其所有质因数都是长度为 <code>k</code> 的质数列表 <code>primes</code> 中的正整数。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 12, primes &#x3D; [2,7,13,19]</span><br><span class="line">输出: 32 </span><br><span class="line">解释: 给定长度为 4 的质数列表 primes &#x3D; [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li><code>1</code> 是任何给定 <code>primes</code> 的超级丑数。</li><li>给定 <code>primes</code> 中的数字以升序排列。</li><li>0 &lt; <code>k</code> ≤ 100, 0 &lt; <code>n</code> ≤ 106, 0 &lt; <code>primes[i]</code> &lt; 1000 。</li><li>第 <code>n</code> 个超级丑数确保在 32 位有符整数范围内。</li></ul><h4 id="1201-丑数-III"><a href="#1201-丑数-III" class="headerlink" title="1201. 丑数 III"></a>1201. 丑数 III</h4><p>请你帮忙设计一个程序，用来找出第 <code>n</code> 个丑数。</p><p>丑数是可以被 <code>a</code> <strong>或</strong> <code>b</code> <strong>或</strong> <code>c</code> 整除的 <strong>正整数</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3, a &#x3D; 2, b &#x3D; 3, c &#x3D; 5</span><br><span class="line">输出：4</span><br><span class="line">解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 4, a &#x3D; 2, b &#x3D; 3, c &#x3D; 4</span><br><span class="line">输出：6</span><br><span class="line">解释：丑数序列为 2, 3, 4, 6, 8, 9, 12... 其中第 4 个是 6。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 5, a &#x3D; 2, b &#x3D; 11, c &#x3D; 13</span><br><span class="line">输出：10</span><br><span class="line">解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1000000000, a &#x3D; 2, b &#x3D; 217983653, c &#x3D; 336916467</span><br><span class="line">输出：1999999984</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n, a, b, c &lt;= 10^9</code></li><li><code>1 &lt;= a * b * c &lt;= 10^18</code></li><li>本题结果在 <code>[1, 2 * 10^9]</code> 的范围内</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 每天学点新算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入输出控制</title>
      <link href="/2020/05/24/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6/"/>
      <url>/2020/05/24/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="输入输出控制"><a href="#输入输出控制" class="headerlink" title="输入输出控制"></a>输入输出控制</h1><p>由于力扣上的题目只注重于算法，而在上机测试的时候会要求写出整个程序，故控制输入输出很关键</p><h3 id="1-给定长度的数组输入-int-double-float-char"><a href="#1-给定长度的数组输入-int-double-float-char" class="headerlink" title="1.给定长度的数组输入(int, double, float, char)"></a>1.给定长度的数组输入(int, double, float, char)</h3><p>使用循环，并且使用scanf/printf可以节省时间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">  tmp.push_back(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-未知长度的数组输入-int-double-float-char"><a href="#2-未知长度的数组输入-int-double-float-char" class="headerlink" title="2.未知长度的数组输入(int, double, float, char)"></a>2.未知长度的数组输入(int, double, float, char)</h3><p>使用vector，对于输入回车字符进行判断以便终止循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">  ans.push_back(tmp);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">cin</span>.<span class="built_in">get</span>() == <span class="string">'\n'</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-string类型的输入"><a href="#3-string类型的输入" class="headerlink" title="3.string类型的输入"></a>3.string类型的输入</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nth_element方法</title>
      <link href="/2020/05/24/nth-element%E6%96%B9%E6%B3%95/"/>
      <url>/2020/05/24/nth-element%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="nth-element方法"><a href="#nth-element方法" class="headerlink" title="nth_element方法"></a>nth_element方法</h1><h3 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">nth_element(first, nth, last, compare);</span><br><span class="line"><span class="comment">//求[first, last]这样一个区间中第n大小的元素，若有特殊的比较方式，则添加compare函数体</span></span><br></pre></td></tr></table></figure><p>由于nth_element方法只排序前n个元素，故使用的时间会更少一点</p><h3 id="题目举例：-973-最接近原点的-K-个点"><a href="#题目举例：-973-最接近原点的-K-个点" class="headerlink" title="题目举例： 973.最接近原点的 K 个点"></a>题目举例： 973.最接近原点的 K 个点</h3><p>我们有一个由平面上的点组成的列表 <code>points</code>。需要从中找出 <code>K</code> 个距离原点 <code>(0, 0)</code> 最近的点。</p><p>（这里，平面上两点之间的距离是欧几里德距离。）</p><p>你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：points &#x3D; [[1,3],[-2,2]], K &#x3D; 1</span><br><span class="line">输出：[[-2,2]]</span><br><span class="line">解释： </span><br><span class="line">(1, 3) 和原点之间的距离为 sqrt(10)，</span><br><span class="line">(-2, 2) 和原点之间的距离为 sqrt(8)，</span><br><span class="line">由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。</span><br><span class="line">我们只需要距离原点最近的 K &#x3D; 1 个点，所以答案就是 [[-2,2]]。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：points &#x3D; [[3,3],[5,-1],[-2,4]], K &#x3D; 2</span><br><span class="line">输出：[[3,3],[-2,4]]</span><br><span class="line">（答案 [[-2,4],[3,3]] 也会被接受。）</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li><li><code>-10000 &lt; points[i][0] &lt; 10000</code></li><li><code>-10000 &lt; points[i][1] &lt; 10000</code></li></ol><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">KClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">  nth_element(points.begin(), points.begin() + K, points.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v2)&#123;</span><br><span class="line">    <span class="keyword">return</span> v1[<span class="number">0</span>]*v1[<span class="number">0</span>] + v1[<span class="number">1</span>]*v1[<span class="number">1</span>] &lt; v2[<span class="number">0</span>]*v2[<span class="number">0</span>] + v2[<span class="number">1</span>]*v2[<span class="number">1</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (points.begin(), points.begin() + K);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每天学点新算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2020/05/23/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2020/05/23/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针的使用"><a href="#双指针的使用" class="headerlink" title="双指针的使用"></a>双指针的使用</h1><h2 id="一、滑动窗口与字符串问题"><a href="#一、滑动窗口与字符串问题" class="headerlink" title="一、滑动窗口与字符串问题"></a>一、滑动窗口与字符串问题</h2><h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingwindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">char</span> c: t) need[c]++;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, valid = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(r &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="comment">//右移判断</span></span><br><span class="line">    <span class="keyword">char</span> c = s[r];</span><br><span class="line">    r++;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    此处根据题目需求进行窗口内的数字更新</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="comment">/*判断左侧收缩条件*/</span>)&#123;</span><br><span class="line">      <span class="comment">//左移一个字符</span></span><br><span class="line">      <span class="keyword">char</span> d = s[l];</span><br><span class="line">      l++;</span><br><span class="line">      <span class="comment">/*窗口内数据更新*/</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目表例"><a href="#题目表例" class="headerlink" title="题目表例"></a>题目表例</h3><p>个人觉得在基本框架之下思路是完整的，判断左侧收缩条件与数据更新是需要深度思考的问题。</p><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h4><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;</span><br><span class="line">输出: &quot;BANC&quot;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>如果 S 中不存这样的子串，则返回空字符串 <code>&quot;&quot;</code>。</li><li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minwindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用need存储t中的字符统计，用window表示滑动窗口中窗口内的字符统计</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c: t) need[c]++;</span><br><span class="line">    <span class="comment">//l, r表示滑动窗口的两边，valid表示有效字符数，方便判断，start表示有效字符开始，len表示长度</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, valid = <span class="number">0</span>, start = <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">    <span class="comment">//确定右移条件</span></span><br><span class="line">    <span class="keyword">while</span>(r &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[r];</span><br><span class="line">        r++;</span><br><span class="line">        <span class="comment">//右移后数字更新</span></span><br><span class="line">        <span class="keyword">if</span>(need.count(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c]) valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//确定左移条件：当滑动窗口中包含了t中所有字符至少一次</span></span><br><span class="line">        <span class="keyword">while</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(r - l &lt; len)&#123;</span><br><span class="line">                start = l;</span><br><span class="line">                len = r - l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[l];</span><br><span class="line">            l++;</span><br><span class="line">            <span class="comment">//左移后滑动窗口里数字更新</span></span><br><span class="line">            <span class="keyword">if</span>(need.count(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d]) valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(len == INT_MAX) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> s.substr(start, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s, t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; minwindow(s, t) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h4><p>给定一个字符串 <strong>s</strong> 和一个非空字符串 <strong>p</strong>，找到 <strong>s</strong> 中所有是 <strong>p</strong> 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 <strong>s</strong> 和 <strong>p</strong> 的长度都不超过 20100。</p><p><strong>说明：</strong></p><ul><li>字母异位词指字母相同，但排列不同的字符串。</li><li>不考虑答案输出的顺序。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c: t) need[c]++;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(r &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[r];</span><br><span class="line">        r++;</span><br><span class="line">        <span class="keyword">if</span>(need.count(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c]) valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r - l &gt;= t.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>()) ans.push_back(l);</span><br><span class="line">            <span class="keyword">char</span> d = s[l];</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">if</span>(need.count(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d]) valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s, t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = findAnagrams(s, t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a>567. 字符串的排列</h4><p>给定两个字符串 <strong>s1</strong> 和 <strong>s2</strong>，写一个函数来判断 <strong>s2</strong> 是否包含 <strong>s1</strong> 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidbaooo&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1&#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidboaoo&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>输入的字符串只包含小写字母</li><li>两个字符串的长度都在 [1, 10,000] 之间</li></ol><h2 id="二、快慢指针"><a href="#二、快慢指针" class="headerlink" title="二、快慢指针"></a>二、快慢指针</h2><h2 id="三、左右指针"><a href="#三、左右指针" class="headerlink" title="三、左右指针"></a>三、左右指针</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 每天学点新算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串和string类</title>
      <link href="/2020/05/21/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8Cstring%E7%B1%BB/"/>
      <url>/2020/05/21/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8Cstring%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串和string类"><a href="#字符串和string类" class="headerlink" title="字符串和string类"></a>字符串和string类</h1><h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a><strong>C风格字符串</strong></h3><p>使用“ ”结尾的一维字符型数组，最终所需要的空间比字符串中字符个数多一个；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++中的一些操作</span></span><br><span class="line"><span class="built_in">strcpy</span>(s1, s2);</span><br><span class="line"><span class="comment">//复制字符串s2到s1</span></span><br><span class="line"><span class="built_in">strcat</span>(s1, s2);</span><br><span class="line"><span class="comment">//连接字符串s2到s1的末尾</span></span><br><span class="line"><span class="built_in">strlen</span>(s1);</span><br><span class="line"><span class="comment">//返回字符串s1的长度</span></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s2);</span><br><span class="line"><span class="comment">//比较两个字符串，若相同则返回0；如果s1大，则返回值大于0，否则小于0；</span></span><br><span class="line"><span class="built_in">strchr</span>(s1, ch);</span><br><span class="line"><span class="comment">//返回一个指针，指向s1中ch字符第一次出现的位置</span></span><br><span class="line"><span class="built_in">strstr</span>(s1, s2);</span><br><span class="line"><span class="comment">//返回一个指针，指向s1中s2第一次出现的位置</span></span><br></pre></td></tr></table></figure><h3 id="C-标准库中的string类"><a href="#C-标准库中的string类" class="headerlink" title="C++标准库中的string类"></a><strong>C++标准库中的string类</strong></h3><p>优势：可以看作基本数据类型使用，操作较char型字符串更加方便</p><h4 id="1-声明一个string类型变量"><a href="#1-声明一个string类型变量" class="headerlink" title="1.声明一个string类型变量"></a>1.声明一个string类型变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">string</span> ss[<span class="number">10</span>];<span class="comment">//声明一个string类型的数组</span></span><br></pre></td></tr></table></figure><h4 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">string</span> s;<span class="comment">//默认初始化，一个空字符串</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"ssss"</span>)</span></span>;<span class="comment">//s1是字面值“ssss”的副本</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//s2是s1的副本</span></span><br><span class="line">    <span class="built_in">string</span> s3=s2;<span class="comment">//s3是s2的副本</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;<span class="comment">//把s4初始化</span></span><br><span class="line">    <span class="built_in">string</span> s5=<span class="string">"hiya"</span>;<span class="comment">//拷贝初始化</span></span><br><span class="line">    <span class="built_in">string</span> s6=<span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'c'</span>);<span class="comment">//拷贝初始化，生成一个初始化好的对象，拷贝给s6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//string s(cp,n)</span></span><br><span class="line">    <span class="keyword">char</span> cs[]=<span class="string">"12345"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(cs,<span class="number">3</span>)</span></span>;<span class="comment">//复制c风格字符串cs的前3个字符到s当中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//string s(s2,pos2)</span></span><br><span class="line">    <span class="built_in">string</span> s8=<span class="string">"asac"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s9</span><span class="params">(s8,<span class="number">2</span>)</span></span>;<span class="comment">//从s2的第二个字符开始拷贝，不能超过s2的size</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//string s(s2,pos2,len2)</span></span><br><span class="line">    <span class="built_in">string</span> s10=<span class="string">"qweqweqweq"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s11</span><span class="params">(s10,<span class="number">3</span>,<span class="number">4</span>)</span></span>;<span class="comment">//s4是s3从下标3开始4个字符的拷贝，超过s3.size出现未定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-字符串的处理方法"><a href="#3-字符串的处理方法" class="headerlink" title="3.字符串的处理方法"></a>3.字符串的处理方法</h4><h5 id="substr"><a href="#substr" class="headerlink" title="substr"></a><strong>substr</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.substr(pos, len);<span class="comment">//返回从pos开始往后长度为len的字符串</span></span><br><span class="line">s.substr(pos);<span class="comment">//从pos开始剩下的所有字符串</span></span><br></pre></td></tr></table></figure><p>如输入的位置超过限制，则会报错</p><h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a><strong>insert</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s.insert(pos, str);<span class="comment">//在pos位置放入一个字符串str</span></span><br><span class="line">s.insert(pos, str, a, n);<span class="comment">//在pos位置插入str中a位置往后n个字符</span></span><br><span class="line">s.insert(pos, cstr, n);<span class="comment">//在pos位置插入c风格字符串从开始到末尾的n个字符</span></span><br><span class="line">s.insert(pos, cstr);<span class="comment">//在pos位置插入cstr字符串</span></span><br><span class="line">s.insert(pos, n, ch);<span class="comment">//在pos位置上插入n个ch字符</span></span><br><span class="line">s.insert(s.it, ch);<span class="comment">//在s的it指向位置前面插入一个字符ch，返回新插入的位置的迭代器</span></span><br><span class="line">s.insert(s.it,n,ch);<span class="comment">//在s的it所指向位置的前面插入n个ch</span></span><br><span class="line">s.insert(it, str.ita, str.itb);<span class="comment">//在it所指向的位置的前面插入[ita,itb)的字符串</span></span><br></pre></td></tr></table></figure><h5 id="erase"><a href="#erase" class="headerlink" title="erase"></a><strong>erase</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.erase (<span class="number">10</span>,<span class="number">8</span>);<span class="comment">//直接指定删除的字符串位置第十个后面的8个字符</span></span><br><span class="line">s.erase (str.<span class="built_in">begin</span>()+<span class="number">9</span>);<span class="comment">//删除迭代器指向的字符</span></span><br><span class="line">str.erase (str.<span class="built_in">begin</span>()+<span class="number">5</span>, str.<span class="built_in">end</span>()<span class="number">-9</span>); <span class="comment">//删除迭代器范围内的字符</span></span><br></pre></td></tr></table></figure><h5 id="append"><a href="#append" class="headerlink" title="append"></a><strong>append</strong></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接追加一个str2的字符串</span></span><br><span class="line">str.append(str2);                       </span><br><span class="line"><span class="comment">//后面追加str3第6个字符开始的3个字符串</span></span><br><span class="line">str.append(str3,<span class="number">6</span>,<span class="number">3</span>);                   </span><br><span class="line"><span class="comment">//追加字符串形参的前5个字符</span></span><br><span class="line">str.append(<span class="string">"dots are cool"</span>,<span class="number">5</span>);          </span><br><span class="line"><span class="comment">//直接添加</span></span><br><span class="line">str.append(<span class="string">"here: "</span>);                   </span><br><span class="line"><span class="comment">//添加10个'.'</span></span><br><span class="line">str.append(<span class="number">10u</span>,<span class="string">'.'</span>);                    </span><br><span class="line"><span class="comment">//添加str3迭代器范围的字符串</span></span><br><span class="line">str.append(str3.begin()+<span class="number">8</span>,str3.end());  </span><br><span class="line"><span class="comment">//最后这个比较特殊，意思是添加5个'A'，实际上参数里面的65对应的asc码就是65</span></span><br><span class="line">str.append&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>,<span class="number">65</span>);                </span><br><span class="line"><span class="comment">//字符串追加也可以用重载运算符实现</span></span><br><span class="line">str+=<span class="string">"lalala"</span>;</span><br></pre></td></tr></table></figure><h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用下标</span></span><br><span class="line"><span class="comment">//第9个字符以及后面的4个字符被str2代替</span></span><br><span class="line">str.replace(<span class="number">9</span>,<span class="number">5</span>,str2);          <span class="comment">// "this is an example string." (1)</span></span><br><span class="line"><span class="comment">//第19个字符串以及后面的5个字符用str的第7个字符以及后面的5个字符代替</span></span><br><span class="line">str.replace(<span class="number">19</span>,<span class="number">6</span>,str3,<span class="number">7</span>,<span class="number">6</span>);     <span class="comment">// "this is an example phrase." (2)</span></span><br><span class="line"><span class="comment">//第8个字符以及后面的9个字符用字符串参数代替</span></span><br><span class="line">str.replace(<span class="number">8</span>,<span class="number">10</span>,<span class="string">"just a"</span>);     <span class="comment">// "this is just a phrase."     (3)</span></span><br><span class="line"><span class="comment">//第8个字符以及后面的5个字符用字符串参数的前7个字符替换</span></span><br><span class="line">str.replace(<span class="number">8</span>,<span class="number">6</span>,<span class="string">"a shorty"</span>,<span class="number">7</span>);  <span class="comment">// "this is a short phrase."    (4)</span></span><br><span class="line"><span class="comment">//第22以及后面的0个字符用3个叹号替换</span></span><br><span class="line">str.replace(<span class="number">22</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="string">'!'</span>);        <span class="comment">// "this is a short phrase!!!"  (5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器                                             </span></span><br><span class="line">str.replace(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>()<span class="number">-3</span>,str3);                    <span class="comment">// "sample phrase!!!"      (1)</span></span><br><span class="line">str.replace(str.<span class="built_in">begin</span>(),str.<span class="built_in">begin</span>()+<span class="number">6</span>,<span class="string">"replace"</span>);             <span class="comment">// "replace phrase!!!"     (3)</span></span><br><span class="line">str.replace(str.<span class="built_in">begin</span>()+<span class="number">8</span>,str.<span class="built_in">begin</span>()+<span class="number">14</span>,<span class="string">"is coolness"</span>,<span class="number">7</span>);    <span class="comment">// "replace is cool!!!"    (4)</span></span><br><span class="line">str.replace(str.<span class="built_in">begin</span>()+<span class="number">12</span>,str.<span class="built_in">end</span>()<span class="number">-4</span>,<span class="number">4</span>,<span class="string">'o'</span>);                <span class="comment">// "replace is cooool!!!"  (5)</span></span><br><span class="line">str.replace(str.<span class="built_in">begin</span>()+<span class="number">11</span>,str.<span class="built_in">end</span>(),str4.<span class="built_in">begin</span>(),str4.<span class="built_in">end</span>());<span class="comment">// "replace is useful."    (6)</span></span><br></pre></td></tr></table></figure><h5 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接把base赋值给str</span></span><br><span class="line">str.assign(base);</span><br><span class="line"><span class="comment">//把base第10个字符以及后面的8个字符赋给str</span></span><br><span class="line">str.assign(base,<span class="number">10</span>,<span class="number">9</span>);</span><br><span class="line"><span class="comment">//把参数中的0到6个字符串赋给str</span></span><br><span class="line">str.assign(<span class="string">"pangrams are cool"</span>,<span class="number">7</span>);</span><br><span class="line"><span class="comment">//直接使用参数赋值</span></span><br><span class="line">str.assign(<span class="string">"c-string"</span>);</span><br><span class="line"><span class="comment">//给str赋值10个'*'字符</span></span><br><span class="line">str.assign(<span class="number">10</span>,<span class="string">'*'</span>);</span><br><span class="line"><span class="comment">//赋值是10个'-'</span></span><br><span class="line">str.assign&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>,<span class="number">0x2D</span>);</span><br><span class="line"><span class="comment">//指定base迭代器范围的字符串</span></span><br><span class="line">str.assign(base.<span class="built_in">begin</span>()+<span class="number">16</span>,base.<span class="built_in">end</span>()<span class="number">-12</span>);</span><br></pre></td></tr></table></figure><h4 id="4-搜索操作"><a href="#4-搜索操作" class="headerlink" title="4.搜索操作"></a>4.搜索操作</h4><h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><h5 id="rfind"><a href="#rfind" class="headerlink" title="rfind"></a>rfind</h5><h5 id="find-…-of"><a href="#find-…-of" class="headerlink" title="find_…_of"></a>find_…_of</h5><h5 id="5-比较和转换"><a href="#5-比较和转换" class="headerlink" title="5.比较和转换"></a>5.比较和转换</h5>]]></content>
      
      
      
        <tags>
            
            <tag> C++程序设计语言学习专题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文字符串</title>
      <link href="/2020/05/21/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/05/21/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>（1）字符串的使用方法</p><p>（2）动态规划</p><p>（3）Manacher算法</p><h3 id="题目描述：最长回文字串"><a href="#题目描述：最长回文字串" class="headerlink" title="题目描述：最长回文字串"></a>题目描述：最长回文字串</h3><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h3 id="字符串复习"><a href="#字符串复习" class="headerlink" title="字符串复习"></a>字符串复习</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 每天学点新算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算&amp;前缀和算法</title>
      <link href="/2020/05/20/%E5%8D%87%E7%BA%A7%E7%89%88%E5%89%8D%E7%BC%80%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2020/05/20/%E5%8D%87%E7%BA%A7%E7%89%88%E5%89%8D%E7%BC%80%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和算法"><a href="#前缀和算法" class="headerlink" title="前缀和算法"></a>前缀和算法</h1><p>在5月15日的文章初步接触了前缀和算法，前缀和算法的主要用途可以归纳为：<strong>利用前缀和的差值来实现统计某一个区间中字符出现次数或者连续和等问题</strong>。</p><p>但在5月20日的每日一题中，前缀和算法、借助位运算实现的状态压缩二者结合可以产生更好的解题思路。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><strong>1371. 每个元音包含偶数次的最长子字符串</strong></p><p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;eleetminicoworoep&quot;</span><br><span class="line">输出：13</span><br><span class="line">解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcodeisgreat&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 e 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;bcbcbc&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 5 x 10^5</code></li><li><code>s</code> 只包含小写英文字母。</li></ul><h3 id="解题方案及优化"><a href="#解题方案及优化" class="headerlink" title="解题方案及优化"></a>解题方案及优化</h3><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 每天学点新算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息的处理与表示</title>
      <link href="/2020/05/19/%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E8%A1%A8%E7%A4%BA/"/>
      <url>/2020/05/19/%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="信息的处理与表示"><a href="#信息的处理与表示" class="headerlink" title="信息的处理与表示"></a>信息的处理与表示</h1><p>解释(interpretation): 赋予可能的位模式以含义</p><p>由于精度有限，浮点数运算是不可结合的。</p><h3 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h3><p>字节（byte）：最小的可寻址的内存单位；</p><p>程序对象（program object）：程序数据、指令和控制信息；</p><h5 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h5><p>一个字节由8位组成，采用16进制（‘0’～‘F’）只需两位便可进行表示</p><p>在C语言中，以0x或者0x开头的数字常量可以被理解为16进制的值</p><h5 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h5><p>字长（word size）：指明指针数据的标称大小；</p><p>“32位程序”和“64位程序”的区别：程序的编译方式，而非运行的机器类型</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解计算机系统读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态机思想</title>
      <link href="/2020/05/18/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%80%9D%E6%83%B3/"/>
      <url>/2020/05/18/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="状态机思想"><a href="#状态机思想" class="headerlink" title="状态机思想"></a>状态机思想</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="688-“马”在棋盘上的概率"><a href="#688-“马”在棋盘上的概率" class="headerlink" title="688. “马”在棋盘上的概率"></a><a href="https://leetcode-cn.com/problems/knight-probability-in-chessboard/" target="_blank" rel="noopener">688. “马”在棋盘上的概率</a></h4><p>难度中等47收藏分享切换为英文关注反馈</p><p>已知一个 <code>N</code>x<code>N</code> 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 <code>(0, 0)</code>，最右下角的记为 <code>(N-1, N-1)</code>。 </p><p>现有一个 “马”（也译作 “骑士”）位于 <code>(r, c)</code> ，并打算进行 <code>K</code> 次移动。 </p><p>如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/knight.png" alt="img"></p><p>现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 <code>K</code> 次或跳到了棋盘外面。</p><p>求移动结束后，“马” 仍留在棋盘上的概率。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: 3, 2, 0, 0</span><br><span class="line">输出: 0.0625</span><br><span class="line">解释: </span><br><span class="line">输入的数据依次为 N, K, r, c</span><br><span class="line">第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。</span><br><span class="line">所以 “马” 在结束后仍在棋盘上的概率为 0.0625。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>N</code> 的取值范围为 [1, 25]</li><li><code>K</code> 的取值范围为 [0, 100]</li><li>开始时，“马” 总是位于棋盘上</li></ul><h3 id="思路一：递归"><a href="#思路一：递归" class="headerlink" title="思路一：递归"></a>思路一：递归</h3><p>写出状态转移方程，每次调用函数即可，但很显然会<strong>超时</strong></p><script type="math/tex; mode=display">f(x)(y)(K)=\sum_{有效位置}f(pr)(pc)(K-1)*0.125</script><h3 id="思路二：动态规划——记忆化搜索，递归的优化"><a href="#思路二：动态规划——记忆化搜索，递归的优化" class="headerlink" title="思路二：动态规划——记忆化搜索，递归的优化"></a>思路二：动态规划——记忆化搜索，递归的优化</h3><p>通过K进行循环，从0开始，每次基于K的状态矩阵更新K+1的状态矩阵</p><h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><h3 id="思路三：深度优先搜索"><a href="#思路三：深度优先搜索" class="headerlink" title="思路三：深度优先搜索"></a>思路三：深度优先搜索</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="状态机的概念与应用"><a href="#状态机的概念与应用" class="headerlink" title="状态机的概念与应用"></a>状态机的概念与应用</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="/2020/05/17/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/05/17/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h3 id="拓扑排序基础知识"><a href="#拓扑排序基础知识" class="headerlink" title="拓扑排序基础知识"></a>拓扑排序基础知识</h3><h3 id="题目：课程表-II"><a href="#题目：课程表-II" class="headerlink" title="题目：课程表 II"></a>题目：课程表 II</h3><p>现在你总共有 <em>n</em> 门课需要选，记为 <code>0</code> 到 <code>n-1</code>。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: <code>[0,1]</code></p><p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p><p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: [0,1]</span><br><span class="line">解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>输入的先决条件是由<strong>边缘列表</strong>表示的图形，而不是邻接矩阵。详情请参见<a href="http://blog.csdn.net/woaidapaopao/article/details/51732947" target="_blank" rel="noopener">图的表示法</a>。</li><li>你可以假定输入的先决条件中没有重复的边。</li></ol><p><strong>提示:</strong></p><ol><li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li><li><a href="https://www.coursera.org/specializations/algorithms" target="_blank" rel="noopener">通过 DFS 进行拓扑排序</a> - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li><li>拓扑排序也可以通过 <a href="https://baike.baidu.com/item/宽度优先搜索/5224802?fr=aladdin&amp;fromid=2148012&amp;fromtitle=广度优先搜索" target="_blank" rel="noopener">BFS</a> 完成。</li></ol><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indeg;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">  <span class="keyword">bool</span> invalid;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    visited[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v: edges[u])&#123;</span><br><span class="line">      <span class="keyword">if</span>(visited[v] == <span class="number">0</span>)&#123;</span><br><span class="line">        dfs(v);</span><br><span class="line">        <span class="keyword">if</span>(invalid) <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(visited[v] == <span class="number">1</span>)&#123;</span><br><span class="line">        invaild = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] == <span class="number">2</span>;</span><br><span class="line">    result.push_back(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisities)</span></span>&#123;</span><br><span class="line">    edges.resize(n);</span><br><span class="line">    visited.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> info: prerequisities)&#123;</span><br><span class="line">      edges[info[<span class="number">1</span>]].push_back(info[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(visited[i] == <span class="number">0</span>) dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(invalid) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    reverse(result.begin(), result.end());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//开辟空间存入关系、入度和结果</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indeg;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span></span>&#123;</span><br><span class="line">    edges.resize(n);</span><br><span class="line">    indeg.resize(n);</span><br><span class="line">    <span class="comment">//将关系转换为图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> info: prerequisites)&#123;</span><br><span class="line">      edges[info[<span class="number">1</span>]].push_back(info[<span class="number">0</span>]);</span><br><span class="line">      indeg[info[<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开辟队列，用以辅助广度优先搜索</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    <span class="comment">//没有先修要求的课程可以直接修读</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(indeg[i] == <span class="number">0</span>) qu.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      <span class="keyword">int</span> cur = qu.front();</span><br><span class="line">      qu.pop();</span><br><span class="line">      result.push_back(cur);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> i: edges[cur])&#123;</span><br><span class="line">        indeg[i]--;<span class="comment">//先修课程每修读一门，则减一</span></span><br><span class="line">        <span class="keyword">if</span>(indeg[i] == <span class="number">0</span>) qu.push(i);<span class="comment">//先修课程修完后，这门课才算修完，入度减一</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result.size() != n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每天学点新算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教务处课程查询网站</title>
      <link href="/2020/05/17/%E6%95%99%E5%8A%A1%E5%A4%84%E8%AF%BE%E7%A8%8B%E6%9F%A5%E8%AF%A2%E7%BD%91%E7%AB%99/"/>
      <url>/2020/05/17/%E6%95%99%E5%8A%A1%E5%A4%84%E8%AF%BE%E7%A8%8B%E6%9F%A5%E8%AF%A2%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p><a href="http://elite.nju.edu.cn/jiaowu/student/teachinginfo/allCourseList.do?method=getCourseList&amp;curTerm=20192&amp;curSpeciality=115&amp;curGrade=2017" target="_blank" rel="noopener">http://elite.nju.edu.cn/jiaowu/student/teachinginfo/allCourseList.do?method=getCourseList&amp;curTerm=20192&amp;curSpeciality=115&amp;curGrade=2017</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 奇奇怪怪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化思想</title>
      <link href="/2020/05/16/%E6%A8%A1%E5%9D%97%E5%8C%96%E6%80%9D%E6%83%B3/"/>
      <url>/2020/05/16/%E6%A8%A1%E5%9D%97%E5%8C%96%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="模块化思想（基于LeetCode-25）"><a href="#模块化思想（基于LeetCode-25）" class="headerlink" title="模块化思想（基于LeetCode-25）"></a>模块化思想（基于LeetCode-25）</h1><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>许多问题都可以分解为不同的子问题，将子问题写成单独的函数，可以使得整个程序结构更加清楚；</p><p>在归并排序中，将归并的步骤单独列出；在快速排序中，将分割的步骤单独列出；在翻转列表的问题中，将翻转的方式单独列出。</p><h3 id="题目：K-个一组翻转链表"><a href="#题目：K-个一组翻转链表" class="headerlink" title="题目：K 个一组翻转链表"></a>题目：K 个一组翻转链表</h3><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。</p><p><em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p><strong>示例：</strong></p><p>给你这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p><p>当 <em>k</em> = 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p><p>当 <em>k</em> = 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code> </p><p><strong>说明：</strong></p><ul><li>你的算法只能使用常数的额外空间。</li><li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode* next;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x): <span class="keyword">int</span> val, next(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  pair&lt;ListNode*, ListNode*&gt; reverse(ListNode* head, ListNode* tail)&#123;</span><br><span class="line">    ListNode* prev = tail-&gt;next;<span class="comment">//作为指针指向的位置</span></span><br><span class="line">    ListNode* p = head;<span class="comment">//当前用于处理的节点</span></span><br><span class="line">    <span class="keyword">while</span>(prev != tail)&#123;</span><br><span class="line">      ListNode* nex = p-&gt;next;</span><br><span class="line">      p-&gt;next = prev;</span><br><span class="line">      prev = p;</span><br><span class="line">      p = nex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>&#123;tail, head&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//在reverse函数中，假定了用于排序的链表前后都有元素，故直接在链表前方添加一个节点</span></span><br><span class="line">    ListNode* newhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    newhead-&gt;next = head;</span><br><span class="line">    <span class="comment">//使用prev表示在进行此次翻转前的位置，prev-&gt;next指向翻转后的起点</span></span><br><span class="line">    ListNode* prev = newhead;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">      <span class="comment">//从prev开始往后遍历k次，确定遍历终点</span></span><br><span class="line">      ListNode* tail = prev;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//保留当前的后一个节点，翻转后的最后一个节点指向此处</span></span><br><span class="line">      ListNode* nex = tail-&gt;next;</span><br><span class="line">      tie&#123;head, tail&#125; = reverse(head, tail);</span><br><span class="line">      <span class="comment">//插入片段</span></span><br><span class="line">      prev-&gt;next = head;</span><br><span class="line">      tail-&gt;next = nex;</span><br><span class="line">      <span class="comment">//更新prev和头部</span></span><br><span class="line">      prev = tail;</span><br><span class="line">      head = tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每天学点新算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2020/05/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/05/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="算法导论专题：排序"><a href="#算法导论专题：排序" class="headerlink" title="算法导论专题：排序"></a>算法导论专题：排序</h1><h3 id="方法一：插入排序"><a href="#方法一：插入排序" class="headerlink" title="方法一：插入排序"></a>方法一：插入排序</h3><h3 id="方法二：归并排序"><a href="#方法二：归并排序" class="headerlink" title="方法二：归并排序"></a>方法二：归并排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFTY 100000000</span></span><br><span class="line"><span class="comment">//创建两个新数组进行归并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> i, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (i + f)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; R, L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= mid; j++)&#123;</span><br><span class="line">        L.push_back(A[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = mid + <span class="number">1</span>; j &lt;= f; j++)&#123;</span><br><span class="line">        R.push_back(A[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    L.push_back(INFTY);</span><br><span class="line">    R.push_back(INFTY);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= f; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L[a] &lt;= R[b])&#123;</span><br><span class="line">            A[j] = L[a];</span><br><span class="line">            a++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            A[j] = R[b];</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> i, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; f)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (i + f)/<span class="number">2</span>;</span><br><span class="line">        mergesort(A, i, mid);</span><br><span class="line">        mergesort(A, mid+<span class="number">1</span>, f);</span><br><span class="line">        merge(A, i, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        A.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    mergesort(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三：随机化快速排序"><a href="#方法三：随机化快速排序" class="headerlink" title="方法三：随机化快速排序"></a>方法三：随机化快速排序</h3><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>（1）最坏时间复杂度为$O(n^2)$，期望时间复杂度为$\Theta(n\lg n)$，具体时间依赖于输入数组的特征；</p><p>（2）隐藏的常数因子很小，并且可以进行原址排序；</p><p>（3）属于非稳定排序方法；</p><h5 id="随机化处理方法"><a href="#随机化处理方法" class="headerlink" title="随机化处理方法"></a>随机化处理方法</h5><p>选取一个数组，取一个随机数，将最末尾元素与随机数指示的元素交换；</p><p>选定末尾元素为主元，遍历数组一遍，分为小于，大于两个部分；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> i, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = A[f];<span class="comment">//取最后一个元素y为基元</span></span><br><span class="line">    <span class="keyword">int</span> k = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= f - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[j] &lt; x)&#123;</span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = A[k];</span><br><span class="line">            A[k] = A[j];</span><br><span class="line">            A[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp2 = A[k+<span class="number">1</span>];</span><br><span class="line">    A[k+<span class="number">1</span>] = A[f];</span><br><span class="line">    A[f] = tmp2;</span><br><span class="line">    <span class="keyword">return</span> k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> i, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; f)&#123;</span><br><span class="line">        <span class="keyword">int</span> q = partition(A, i, f);</span><br><span class="line">        QuickSort(A, i, q<span class="number">-1</span>);</span><br><span class="line">        QuickSort(A, q+<span class="number">1</span>, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> input;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;input);</span><br><span class="line">        A.push_back(input);</span><br><span class="line">    &#125;</span><br><span class="line">    QuickSort(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法四：桶排序"><a href="#方法四：桶排序" class="headerlink" title="方法四：桶排序"></a>方法四：桶排序</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 《算法导论》学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和算法</title>
      <link href="/2020/05/15/%E5%89%8D%E7%BC%80%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2020/05/15/%E5%89%8D%E7%BC%80%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和算法"><a href="#前缀和算法" class="headerlink" title="前缀和算法"></a>前缀和算法</h1><p>前缀和，取余，用hash表维护次数，方便统计；</p><h3 id="题目描述560"><a href="#题目描述560" class="headerlink" title="题目描述560"></a>题目描述560</h3><p><strong>560. 和为K的子数组</strong></p><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p><p><strong>示例 1 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure><p><strong>说明 :</strong></p><ol><li>数组的长度为 [1, 20,000]。</li><li>数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]。</li></ol><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p><strong>方法一：循环</strong></p><p>对每一个以i开头的元素，计算其接下来所有长度的情况，时间复杂度为$O(n^2)$</p><p><strong>方法二：前缀和</strong></p><p>对于某一个从$i$到$j$连续且和为$k$的数组，相当于从起点加到$j$减去从起点加至$i$的和，使用hash表对上述和出现的数目进行管理即可。其中本题目会用到find函数会使得过程大大简化.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用前缀和计算的方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(Vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">  hash[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> tmp = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums)&#123;</span><br><span class="line">    tmp += x;</span><br><span class="line">    <span class="keyword">if</span>(hash.<span class="built_in">find</span>(tmp - x) != hash.<span class="built_in">end</span>()) cnt += hash[tmp - x];<span class="comment">//a</span></span><br><span class="line">    hash[tmp]++;<span class="comment">//b</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题最大的问题在于思路：将枚举的方法转换为遍历求和后求差值，并用hash表对次数进行管理；</p><p>关于代码实现：实现对hash\vector等数据结构使用find函数时，若未查到，则会返回end()的值；</p><p>深入思考，a和b两行代码能够对调？显然是不能的，考虑极端情况，k=0时若对调会导致得到的结果相对正确答案偏大，故无法对调。（计算机很考边界条件啊！！！）</p><h3 id="题目描述974"><a href="#题目描述974" class="headerlink" title="题目描述974"></a>题目描述974</h3><p><strong>974.和可被 K 整除的子数组</strong></p><p>给定一个整数数组 <code>A</code>，返回其中元素之和可被 <code>K</code> 整除的（连续、非空）子数组的数目。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [4,5,0,-2,-3,1], K &#x3D; 5</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">有 7 个子数组满足其元素之和可被 K &#x3D; 5 整除：</span><br><span class="line">[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 30000</code></li><li><code>-10000 &lt;= A[i] &lt;= 10000</code></li><li><code>2 &lt;= K &lt;= 10000</code></li></ol><h3 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h3><p>使用前缀和算法，考虑每个位置sum的余数，余数为0自然可以整除，除此外，对于前方余数相同的指标个数，即可表示为子数组数；</p><p>注意，针对负数的取余具有特殊性；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarrayDivByk</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;<span class="comment">//用hash表管理余数出现的次数</span></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">    sum += A[i];</span><br><span class="line">    <span class="keyword">int</span> tmp = (sum%K + K)%K;</span><br><span class="line">    <span class="keyword">if</span>(tmp == <span class="number">0</span>) ans++;</span><br><span class="line">    ans += cnt[tmp];</span><br><span class="line">    cnt[tmp]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每天学点新算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统漫游</title>
      <link href="/2020/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
      <url>/2020/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串相乘</title>
      <link href="/2020/05/14/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
      <url>/2020/05/14/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串相乘（竖式模拟）"><a href="#字符串相乘（竖式模拟）" class="headerlink" title="字符串相乘（竖式模拟）"></a>字符串相乘（竖式模拟）</h1><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p><strong>示例 1:</strong></p><p>输入: num1 = “2”, num2 = “3”<br>输出: “6”<br><strong>示例 2:</strong></p><p>输入: num1 = “123”, num2 = “456”<br>输出: “56088”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num1 和 num2 的长度小于110。</span><br><span class="line">num1 和 num2 只包含数字 0-9。</span><br><span class="line">num1 和 num2 均不以零开头，除非是数字 0 本身。</span><br><span class="line">不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</span><br></pre></td></tr></table></figure><p><strong>算法思想</strong></p><p>从小学的竖式计算中获得启发，从最低位开始计算。</p><p>最开始不考虑进位，最后统一进行进位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num1 == <span class="string">'0'</span> || num2 == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">  <span class="keyword">int</span> n1 = num1.<span class="built_in">size</span>(), n2 = num2.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">//字符串翻转方便处理</span></span><br><span class="line">  reverse(num1.<span class="built_in">begin</span>, num1.<span class="built_in">end</span>());</span><br><span class="line">  reverse(num2.<span class="built_in">begin</span>, num2.<span class="built_in">end</span>());</span><br><span class="line">  <span class="comment">//定义数组存储所有的相乘结果，暂时不进位</span></span><br><span class="line">  <span class="keyword">int</span> ans[<span class="number">225</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; ++i)&#123;</span><br><span class="line">      ans[i+j] += (num1[i] - <span class="string">'0'</span>)*(num2[i] - <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//进位处理</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1+n2; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ans[i] &gt; <span class="number">9</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> tmp = ans[i]%<span class="number">9</span>;</span><br><span class="line">      ans[i+<span class="number">1</span>] += ans[i]/<span class="number">10</span>;</span><br><span class="line">      ans[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//从头开始判断。由于位数较高的结果应该排在前方，故从后向前进行。</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">string</span> output = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">while</span>(ans[i] == <span class="number">0</span>)&#123;</span><br><span class="line">    i--;</span><br><span class="line">  &#125;<span class="comment">//只有0这种情况才会导致首位为0，其余情况下不为0的位置即为首位，可以开始进行处理</span></span><br><span class="line">  <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    output += to_string(ans[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>在遇到计算机无法直接处理的大数时，一般需要联想到人工的做法进行模拟；</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每天学点新算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hierholzer算法</title>
      <link href="/2020/05/13/Hierholzer%E7%AE%97%E6%B3%95/"/>
      <url>/2020/05/13/Hierholzer%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Hierholzer算法的应用"><a href="#Hierholzer算法的应用" class="headerlink" title="Hierholzer算法的应用"></a>Hierholzer算法的应用</h1><h4 id="Hierholzer算法的基本过程"><a href="#Hierholzer算法的基本过程" class="headerlink" title="Hierholzer算法的基本过程"></a>Hierholzer算法的基本过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1) 选择任一顶点为起点，遍历所有相邻边。</span><br><span class="line">(2) 深度搜索，访问相邻顶点。将经过的边都删除。</span><br><span class="line">(3) 如果当前顶点没有相邻边，则将顶点入栈。</span><br><span class="line">(4) 栈中的顶点倒序输出，就是从起点出发的欧拉回路。</span><br></pre></td></tr></table></figure><p><strong>性质一</strong>：如果该图为欧拉图，则栈底的必定为起点。如果该图为半欧拉图，则栈底部存储的是与起点不同的另外一个奇度数顶点。</p><p><strong>性质二</strong>：如果该图为欧拉图(/半欧拉图)，则栈中的自底到顶第$n$个顶点就是欧拉回路(/欧拉路径)上的第$n$个顶点。</p><h4 id="问题一：LeetCode-332-重新安排行程"><a href="#问题一：LeetCode-332-重新安排行程" class="headerlink" title="问题一：LeetCode-332 重新安排行程"></a>问题一：LeetCode-332 重新安排行程</h4><p>给定一个机票的字符串二维数组 <code>[from, to]</code>，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 出发。</p><p><strong>说明:</strong></p><ol><li>如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前</li><li>所有的机场都用三个大写字母表示（机场代码）。</li><li>假定所有机票至少存在一种合理的行程。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</span><br><span class="line">输出: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</span><br><span class="line">输出: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</span><br><span class="line">解释: 另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]。但是它自然排序更大更靠后。</span><br></pre></td></tr></table></figure><p><strong>代码实现与注释</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明全局变量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; adjGraph;<span class="comment">//构造邻接图，类似情况均可采用此数据结构</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; tickets;<span class="comment">//边的存在情况</span></span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> from)</span></span>&#123;</span><br><span class="line">  <span class="comment">//遍历起点的所有边</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [to,num]: adjGraph[from])&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//此时边不存在</span></span><br><span class="line">    num--;</span><br><span class="line">    dfs(to);<span class="comment">//深度搜索下个顶点的所有边</span></span><br><span class="line">  &#125;</span><br><span class="line">  ans.push_back(from);<span class="comment">//最后才确定这条边是否可用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">FindInternart</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; _tickets)</span></span>&#123;</span><br><span class="line">  tickets = _tickets;</span><br><span class="line">  <span class="comment">//构造邻接图</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ticket: tickets)&#123;</span><br><span class="line">    adjGraph[ticket[<span class="number">0</span>]][ticket[<span class="number">1</span>]]++;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="string">"JFK"</span>);</span><br><span class="line">  <span class="comment">//根据算法本质，是逆向推断，故需在最后反向处理</span></span><br><span class="line">  reverse(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题二：LeetCode-753-破解保险箱"><a href="#问题二：LeetCode-753-破解保险箱" class="headerlink" title="问题二：LeetCode-753 破解保险箱"></a>问题二：LeetCode-753 破解保险箱</h4><p>有一个需要密码才能打开的保险箱。密码是 <code>n</code> 位数, 密码的每一位是 <code>k</code> 位序列 <code>0, 1, ..., k-1</code> 中的一个 。</p><p>你可以随意输入密码，保险箱会自动记住最后 <code>n</code> 位输入，如果匹配，则能够打开保险箱。</p><p>举个例子，假设密码是 <code>&quot;345&quot;</code>，你可以输入 <code>&quot;012345&quot;</code> 来打开它，只是你输入了 6 个字符.</p><p>请返回一个能打开保险箱的最短字符串。</p><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 1, k &#x3D; 2</span><br><span class="line">输出: &quot;01&quot;</span><br><span class="line">说明: &quot;10&quot;也可以打开保险箱。</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 2, k &#x3D; 2</span><br><span class="line">输出: &quot;00110&quot;</span><br><span class="line">说明: &quot;01100&quot;, &quot;10011&quot;, &quot;11001&quot; 也能打开保险箱。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>n</code> 的范围是 <code>[1, 4]</code>。</li><li><code>k</code> 的范围是 <code>[1, 10]</code>。</li><li><code>k^n</code> 最大可能为 <code>4096</code>。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 每天学点新算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣刷题日记</title>
      <link href="/2020/05/04/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2020/05/04/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="（1）三数之和问题（15，16）、四数之和问题（18）"><a href="#（1）三数之和问题（15，16）、四数之和问题（18）" class="headerlink" title="（1）三数之和问题（15，16）、四数之和问题（18）"></a>（1）三数之和问题（15，16）、四数之和问题（18）</h4><p><strong>解决思路</strong>：选定起点，使用排序+双指针的做法</p><p><strong>解决难点</strong>：怎么排除重复项目：直接进入下一循环，如果值与上一个相等，则直接跳过，对于四个元素都是如此</p><p><strong>扩展问题</strong>：四数之和（18）：在三数之和上加一个循环</p><h4 id="（2）删除链表倒数第N个节点（19）"><a href="#（2）删除链表倒数第N个节点（19）" class="headerlink" title="（2）删除链表倒数第N个节点（19）"></a>（2）删除链表倒数第N个节点（19）</h4><p><strong>解决思路</strong>：使用双指针，一个置于第N(label = n - 1)个节点，另一个置于第1(label = 0)个，之后一起循环，直至后面一个节点循环至NULL处；</p><h3 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h3><p>问题：选择数组中超过一定数量的数字的集合（LeetCode#229）</p><p>基本思路：使用比较抵消法，选取一个候选人，依次向后比较，如果不相同的话，则在原来的计数基础上抵消一个1，在所有的票数都被抵消后，则考虑更换候选人；候选人数目根据最多可能的结果来确定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">  <span class="comment">//确定候选人</span></span><br><span class="line">  <span class="keyword">int</span> candiate1 = <span class="number">0</span>, cnt1 = <span class="number">0</span>, candiate2 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i] == candiate1) cnt1++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candiate2) cnt2++:</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt1 == <span class="number">0</span>)&#123;</span><br><span class="line">      candiate1 = nums[i];</span><br><span class="line">      cnt1 = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt2 == <span class="number">0</span>)&#123;</span><br><span class="line">      candiate2 = nums[i];</span><br><span class="line">      cnt2 = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      cnt1--, cnt2--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i: nums)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == candiate1) cnt1++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == candiate2) cnt2++;<span class="comment">//使用else if可以保证两个候选人结果不一样</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cnt1 &gt; n/<span class="number">3</span>) ans.push_back(candiate1);</span><br><span class="line">  <span class="keyword">if</span>(cnt2 &gt; n/<span class="number">3</span>) ans.push_back(candiate2);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定要记住，hash表初始的value是0！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 保研冲刺 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法分析学习笔记</title>
      <link href="/2020/04/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/04/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="（1）选择排序-Theta-n-2"><a href="#（1）选择排序-Theta-n-2" class="headerlink" title="（1）选择排序$\Theta(n^2)$"></a>（1）选择排序$\Theta(n^2)$</h3><h3 id="（2）归并排序-Theta-n-lg-n"><a href="#（2）归并排序-Theta-n-lg-n" class="headerlink" title="（2）归并排序$\Theta(n\lg n)$"></a>（2）归并排序$\Theta(n\lg n)$</h3><h3 id="（3）求解递归复杂度：特征方程、主定理"><a href="#（3）求解递归复杂度：特征方程、主定理" class="headerlink" title="（3）求解递归复杂度：特征方程、主定理"></a>（3）求解递归复杂度：特征方程、主定理</h3><h3 id="第四章：分治策略"><a href="#第四章：分治策略" class="headerlink" title="第四章：分治策略"></a>第四章：分治策略</h3><p>求解方法：代入法、递归树法、主定理</p><h4 id="4-1-最大子数组问题：寻找数组A的连续和最大的子数组"><a href="#4-1-最大子数组问题：寻找数组A的连续和最大的子数组" class="headerlink" title="4.1 最大子数组问题：寻找数组A的连续和最大的子数组"></a>4.1 最大子数组问题：寻找数组A的连续和最大的子数组</h4><p>原始问题：最大化股票收益</p><p>将原始问题依照中间点分为两段，最大子数组一定属于三种情况之一：完全左侧、完全右侧、跨越中心；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺带锻炼一下结构体的基本操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFTY -10000000;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> left;</span><br><span class="line">  <span class="keyword">int</span> right;</span><br><span class="line">  <span class="keyword">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对经过中点的的最长子数组</span></span><br><span class="line"><span class="function">state <span class="title">Maxsoncrossarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">    state ans;</span><br><span class="line">    <span class="keyword">int</span> max_left, max_right, left_sum, right_sum, sum;</span><br><span class="line">    left_sum = INFTY;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    max_left = mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;= l; i--)&#123;</span><br><span class="line">        sum += A[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= left_sum)&#123;</span><br><span class="line">            left_sum = sum;</span><br><span class="line">            max_left = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max_right = mid + <span class="number">1</span>;</span><br><span class="line">    right_sum = INFTY;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid+<span class="number">1</span>; i &lt;= r; ++i)&#123;</span><br><span class="line">        sum += A[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= right_sum)&#123;</span><br><span class="line">            right_sum = sum;</span><br><span class="line">            max_right = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.left = max_left;</span><br><span class="line">    ans.right = max_right;</span><br><span class="line">    ans.sum = left_sum + right_sum;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">state <span class="title">Maxsonarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    state ans, tmp1, tmp2, tmp3;</span><br><span class="line">    <span class="comment">//特殊情况，若只有一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        ans.left = l;</span><br><span class="line">        ans.right = r;</span><br><span class="line">        ans.sum = A[l];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">        tmp1 = Maxsonarray(A, l, mid);</span><br><span class="line">        tmp2 = Maxsonarray(A, mid+<span class="number">1</span>, r);</span><br><span class="line">        tmp3 = Maxsoncrossarray(A, l, r, mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp1.sum &gt;= tmp2.sum &amp;&amp; tmp1.sum &gt; tmp3.sum) <span class="keyword">return</span> tmp1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tmp2.sum &gt;= tmp1.sum &amp;&amp; tmp2.sum &gt; tmp3.sum) <span class="keyword">return</span> tmp2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> tmp3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        A.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    state ans = Maxsonarray(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n%d"</span>, ans.left, ans.right, ans.sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充说明：</strong>还有一种很简单的方法，动态规划，状态转换方程表示如下；</p><script type="math/tex; mode=display">dp[i] = \max(dp[i-1]+nums[i], nums[i]);</script><h4 id="4-2-矩阵乘法的Strassen算法"><a href="#4-2-矩阵乘法的Strassen算法" class="headerlink" title="4.2 矩阵乘法的Strassen算法"></a>4.2 矩阵乘法的Strassen算法</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记</title>
      <link href="/2020/04/30/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/04/30/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>强制类型转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(type_name) expression;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python玩转数据</title>
      <link href="/2020/04/19/python%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE/"/>
      <url>/2020/04/19/python%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="MODULE-0"><a href="#MODULE-0" class="headerlink" title="MODULE 0"></a>MODULE 0</h2><h4 id="走进python"><a href="#走进python" class="headerlink" title="走进python"></a>走进python</h4><p>hello world</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mystring = <span class="string">'hello world'</span></span><br><span class="line">print(mystring)</span><br></pre></td></tr></table></figure><p>运行程序：（1）交互式解释器shell（2）文件（以.py为扩展名）</p><p>安装第三方库： pip install <em>(库名)</em></p><p>输出：利用Print函数 参数为变量名or字符串</p><p>输入：Input函数  变量名 = 变量类型（ input(‘提示语句’)）</p><h4 id="python风格"><a href="#python风格" class="headerlink" title="python风格"></a>python风格</h4><p>注释：#开头表示</p><p>换行：三引号下的数据可以不用加换行符号；</p><p>缩进：不需要括号，直接用冒号，然后控制缩进；</p><h4 id="python语法基础"><a href="#python语法基础" class="headerlink" title="python语法基础"></a>python语法基础</h4><p>变量：标注对象or引用对象；变量名命名受C语言影响：首字母必须是字母or下划线；其余可以是字母、下划线、数字；大小写敏感；尽量避免下划线开头的变量名；尽量不使用拼音，使用英文；驼峰式、下划线式不混用；关键字不可用做变量名；</p><p>运算符有优先级顺序，表达式一定要有运算结果；</p><p>赋值：python是动态强类型语言，通过引用的方式赋值，无需显式声明变量类型；可用<em>id()</em>函数查看内存空间；[-5,256]范围内的数字可以存储在同一内存空间，方便使用；增量赋值，链式赋值，多重赋值；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多重赋值的本质是元组打包、序列解包</span></span><br><span class="line">x,y = y,x</span><br><span class="line">PI, r = <span class="number">3.1415926</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure><p>语句：用于完成一个任务；表达式：任务中的一步；</p><h4 id="Python数据类型"><a href="#Python数据类型" class="headerlink" title="Python数据类型"></a>Python数据类型</h4><p>（1）整型（int）：Python中整型基本不存在溢出问题</p><p>（2）布尔型（bool）：其实整型的一个子类，只有true\false两个值，本质上也是由1\0存储的</p><p>（3）浮点型（float）：数学中的实数，用类似科学计数法表示</p><p>（4）复数型（complex）：虚数部分用$j$标记，可以使用.real和.imag分别取得实数和复数部分，可以用.conjugate获得共轭复数</p><p>（5）字符串：可使用单引号、双引号和三引号（三个单引号）鉴别，三引号中可以自由使用单引号和双引号；可以使用索引操作符，可以使用+将两个字符串连接在一起；</p><p>（6）映射类型-字典：用大括号来鉴别，成员是有键和值成对的对象，类似于哈希表的键值对；</p><h4 id="Python基本运算"><a href="#Python基本运算" class="headerlink" title="Python基本运算"></a>Python基本运算</h4><p>（1）算术运算：+、-、<em>、/、*</em>（乘方运算）、%（取余）、//（整除）</p><p>（2）比较运算：Python可以使用连续的比较运算；&gt;、&lt;、==、!=；</p><p>（3）逻辑运算：not \ and \or （与C++中不一样，Python中可直接使用中文）</p><p>（4）字符运算符：r\R表示原始字符串，用于一些不需要转义自负的地方</p><p>比较运算和逻辑运算的结果为bool型的值；</p><h4 id="Python的函数、模块"><a href="#Python的函数、模块" class="headerlink" title="Python的函数、模块"></a>Python的函数、模块</h4><p>（1）函数：完成特定功能的一段代码；</p><p>内建函数：数值型内建函数、实用函数；可用help()查看某个内建函数的信息；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">round(),四舍五入取整;(内建函数)</span><br><span class="line">floor(),向下取整（需<span class="keyword">import</span> math）</span><br></pre></td></tr></table></figure><p>标准库函数（Python标准支持，需要倒入模块）、第三方库（需安装）、用户自定义（自行设计）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;模块名<span class="number">1</span>&gt;&lt;模块名<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">from</span> &lt;模块名&gt; <span class="keyword">import</span> &lt;模块部分&gt;</span><br></pre></td></tr></table></figure><p>包（Package）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个有层次的文件目录结构；</span><br><span class="line">定义了一个由模块和子包组成的Python应用程序执行环境；</span><br></pre></td></tr></table></figure><p>库（library）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一组模块集合</span><br></pre></td></tr></table></figure><p>print可以支持同时输出多个变量；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runfile(),</span><br></pre></td></tr></table></figure><h2 id="MODULE-1"><a href="#MODULE-1" class="headerlink" title="MODULE 1"></a>MODULE 1</h2><p>三种结构：顺序、选择、重复</p><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;条件表达式&gt;：</span><br><span class="line">  &lt;执行语句&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件表达式&gt;:</span><br><span class="line">  &lt;执行语句&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件表达式&gt;:</span><br><span class="line">  &lt;执行语句&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  &lt;执行语句&gt;</span><br></pre></td></tr></table></figure><p>另外，还可以使用条件嵌套和条件返回式；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">if</span> &lt;expression&gt; <span class="keyword">else</span> y</span><br></pre></td></tr></table></figure><h4 id="range-函数：用于产生一组有规矩的数列"><a href="#range-函数：用于产生一组有规矩的数列" class="headerlink" title="range()函数：用于产生一组有规矩的数列"></a>range()函数：用于产生一组有规矩的数列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">range(start, end, step)</span><br><span class="line">range(start, end)</span><br><span class="line">range(end)</span><br><span class="line"><span class="comment">#包含起始值，不包含终止值，默认步长为1，起始值为0</span></span><br><span class="line"><span class="comment">#循环中使用较多，适合与for连用</span></span><br></pre></td></tr></table></figure><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expression&gt;:</span><br><span class="line">  &lt;expression&gt;</span><br><span class="line"><span class="comment">#while循环在条件满足时循环</span></span><br><span class="line"><span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable_object:</span><br><span class="line">  suite_to_repeat</span><br><span class="line"><span class="comment">#获取可迭代对象，产生迭代器；可以用作列表解析与生成表达式，还可以遍历数据集</span></span><br><span class="line"><span class="comment">#索引迭代seq[i]、序列本身迭代</span></span><br></pre></td></tr></table></figure><p>for循环是一个语法糖：将复杂的语法规则内含化；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> x &lt; y:</span><br><span class="line">    x, y = y, x</span><br><span class="line">  <span class="keyword">while</span> x % y != <span class="number">0</span>:</span><br><span class="line">    r = x%y</span><br><span class="line">    x = y</span><br><span class="line">    y = r</span><br><span class="line">  <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p>其它语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">break：跳出当前循环，提前终止；</span><br><span class="line">continue: 条件满足时跳过continue后的语句，停止当前，进入下一轮；</span><br><span class="line">else: 如果循环从break截止，无法执行；若是正常结束的，则会执行else语句；</span><br></pre></td></tr></table></figure><p>素数的计算机定义：如果无法被2到sqrt(N)之间的数整除，则为素数</p><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> &lt;函数名&gt;<span class="params">(&lt;参数&gt;)</span>:</span><span class="comment">#相比于C++，python中不用写出参数的数据类型</span></span><br><span class="line">  <span class="string">'&lt;函数的注释&gt;'</span><span class="comment">#可以用print(&lt;函数名&gt;)调用</span></span><br><span class="line">  &lt;函数体&gt;</span><br><span class="line"><span class="comment">#最后一定要有return</span></span><br></pre></td></tr></table></figure><p><strong>默认参数</strong></p><p>（1）程序中若需要有默认参数，直接用赋值语句写出；</p><p>（2）默认参数可修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y = True)</span></span></span><br><span class="line"><span class="function">&gt;&gt;&gt; <span class="title">f</span><span class="params">(<span class="number">68</span>,False)</span>#改变默认参数<span class="title">y</span>的值</span></span><br></pre></td></tr></table></figure><p>（3）默认参数后面不允许跟上非默认参数，故默认参数一定要放到最后；</p><p><strong>关键字参数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span></span><br><span class="line">f(y = , x = )<span class="comment">#直接引用关键字参数赋值</span></span><br></pre></td></tr></table></figure><p>一旦使用了关键字参数，则所有的参数都需使用为关键字参数</p><p><strong>传递函数</strong></p><p>函数可以像参数一样传递给另外一个函数；</p><p><strong>lambda函数（匿名函数）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_add</span><span class="params">(x,y)</span>:</span> <span class="keyword">return</span> x+y</span><br><span class="line">my_add = <span class="keyword">lambda</span> x,y: x + y</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>（1）递归一定要有停止条件</p><p>（2）递归的系统消耗更大，一层一层调用，一层一层返回</p><p><em>有些问题找不到合适的循环方案，则只有使用递归的方法</em></p><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>全局变量：位于代码的主题部分，函数内和主体部分都可见</p><p>局部变量：函数模块中的变量</p><p>若全局变量和局部变量同名，则遵循“内层屏蔽外层”的原则。函数内部也可修改全局变量的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> a<span class="comment">#声明a为一个全局变量</span></span><br></pre></td></tr></table></figure><h4 id="常用python标准库函数"><a href="#常用python标准库函数" class="headerlink" title="常用python标准库函数"></a>常用python标准库函数</h4><p>可用dir(&lt;模块名&gt;)查看其中的函数</p><p>math模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">math.pi<span class="comment">#常数</span></span><br><span class="line">math.e<span class="comment">#常数</span></span><br><span class="line">help(&lt;函数名&gt;)<span class="comment">#了解函数功能</span></span><br><span class="line">math.ceil()<span class="comment">#向上取整</span></span><br><span class="line">math.floor()<span class="comment">#向下取整</span></span><br><span class="line">math.pow(,)<span class="comment">#幂运算</span></span><br><span class="line">math.sqrt()<span class="comment">#开方运算</span></span><br><span class="line">math.degrees()<span class="comment">#弧度转角度</span></span><br><span class="line">math.radians()<span class="comment">#角度转弧度</span></span><br></pre></td></tr></table></figure><p>os模块：与操作系统交互</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.getcwd()<span class="comment">#获得当前工作目录</span></span><br><span class="line">os.chdir()<span class="comment">#更改目录</span></span><br><span class="line">os.rename(,)<span class="comment">#重命名</span></span><br><span class="line">os.remove()<span class="comment">#删掉文件</span></span><br></pre></td></tr></table></figure><p>random模块：随机数生成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.choice([,,])<span class="comment">#从序列中获得随机值</span></span><br><span class="line">random.randint(start, end)<span class="comment">#生成随机整数</span></span><br><span class="line">random.randrange(start, end, step)<span class="comment">#获取随机正数</span></span><br><span class="line">random.random<span class="comment">#生成0到1.0之间的随机浮点数</span></span><br><span class="line">random.uniform(start, end)<span class="comment">#生成start到end的随机浮点数</span></span><br><span class="line">random.simple(range(), num)<span class="comment">#在范围内随机生成num个随机数</span></span><br><span class="line">random.shuffle([,,])<span class="comment">#将列表中的元素打乱，适合抽签</span></span><br></pre></td></tr></table></figure><p>datetime模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line">dt = date.today()<span class="comment">#</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> time</span><br><span class="line">tm = time(<span class="number">23</span>,<span class="number">20</span>,<span class="number">25</span>)<span class="comment">#生成23:20:25这个时间</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">dt = datatime.now()<span class="comment">#本地时间，精确至毫秒</span></span><br><span class="line">print(dt.strftime(<span class="string">"%a, %b %d %Y %H:%M"</span>))</span><br><span class="line">dt = datatime(<span class="number">2017</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">23</span>,<span class="number">29</span>)<span class="comment">#生成时间</span></span><br><span class="line">ts = dt.timestamp()<span class="comment">#转化成时间戳</span></span><br><span class="line">dt = datatime.fromtimestamp(ts)<span class="comment">#重新转为当前时间</span></span><br></pre></td></tr></table></figure><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>错误分类：语法错误，运行时刻错误，逻辑错误</p><p>Python通常用异常对象表示异常；若无法捕捉异常对象，则会回溯找到异常出现点；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir(_builtins_)#查看异常类</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#try_except</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  &lt;被检测的语句块&gt;</span><br><span class="line"><span class="keyword">except</span> &lt;异常类&gt; <span class="keyword">as</span> &lt;错误原因名（自定义）&gt;:</span><br><span class="line">  &lt;执行语句&gt;</span><br><span class="line"><span class="keyword">else</span>:<span class="comment">#没有except引发产生的语句</span></span><br><span class="line">  &lt;执行语句&gt;</span><br><span class="line"><span class="keyword">finally</span>:<span class="comment">#任何情况下,finally都会执行</span></span><br><span class="line">  &lt;执行语句&gt;</span><br><span class="line"><span class="comment">#还可以使用多个except语句捕捉多个异常</span></span><br><span class="line"><span class="comment">#也可以直接使用空的except语句</span></span><br><span class="line"><span class="comment">#可以使用while True语句 + break使得知道正常时结束运行</span></span><br></pre></td></tr></table></figure><p>操作文件时一般推荐使用with语句；</p><h2 id="MODULE-2-数据获取"><a href="#MODULE-2-数据获取" class="headerlink" title="MODULE 2 数据获取"></a>MODULE 2 数据获取</h2><h4 id="本地数据获取"><a href="#本地数据获取" class="headerlink" title="本地数据获取"></a>本地数据获取</h4><p>打开文件-读取数据-写入数据-关闭文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用open函数，文件名（包含路径信息），模式，大小（后两个参数是必须的）</span></span><br><span class="line">file_obj = open(filename, mode = <span class="string">'r'</span>, buffering = <span class="number">-1</span>, )</span><br><span class="line"><span class="comment">#mode: r读文件，w写文件（会清空原有内容），a追加（在尾部增加）;后面如果加b就表示二进制文件的操作</span></span><br></pre></td></tr></table></figure><p>open()函数返回一个文件对象，文件对象可迭代，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对象名.方法</span></span><br><span class="line">f.read(), f.write(), f.close(), f.seek()</span><br><span class="line"><span class="comment">#write函数可以将一个字符串写入文件</span></span><br><span class="line"><span class="comment">#read函数：不带参数则表示从当前位置读到结尾，用字符串返回；带参数</span></span><br><span class="line"><span class="comment">#readlines读取多行数据，writelines写入多行数据</span></span><br></pre></td></tr></table></figure><p>with语句在执行后会直接关闭文件，则无需继续使用close关闭文件；</p><p>python在读取文件时不会自动删除换行符；</p><p>读写时共用同一个文件指针，数据从指针所在位置开始读写；seek函数可移动指针解决上述问题：seek函数有两个参数，一个表示偏移量，一个表示起始位置（默认值为0）;seek(5,0)表示从文件开头移动至5个位置处；</p><p>统计文件中的行数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">with</span> open(<span class="string">'file_name'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.readline()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  print(file_name + <span class="string">'does not exist'</span>)</span><br><span class="line">lens = len(data)</span><br><span class="line">print(<span class="string">'the data has'</span> + str(lens) + <span class="string">'lines'</span>)</span><br><span class="line"><span class="comment">#如果需要使用多个数据，则定义一个新的函数</span></span><br><span class="line">files = [<span class="string">'date1.txt'</span>,<span class="string">'data2.txt'</span>,<span class="string">'data3.txt'</span>,<span class="string">'data4.txt'</span>]</span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> files:</span><br><span class="line">  count(fname)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">'../data'</span></span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">  <span class="keyword">if</span> (fname.endswith(<span class="string">'txt'</span>)):<span class="comment">#表示文件格式,此处只会读取.txt文件</span></span><br><span class="line">    file_path = os.path.join(path, fname)</span><br><span class="line">    count(file_path)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">'./output'</span>):</span><br><span class="line">      shutil.rmtree(<span class="string">'./output'</span>) <span class="comment">#可以递归的删除非空目录</span></span><br><span class="line">    os.mkdir(<span class="string">'./output'</span>)<span class="comment">#可以创建自己的目录</span></span><br></pre></td></tr></table></figure><h4 id="网络数据获取"><a href="#网络数据获取" class="headerlink" title="网络数据获取"></a>网络数据获取</h4><p>（1）抓取：urllib内建模块、Requests第三方库、Scrapy框架</p><p>（2）解析：BeautifulSoup库，re模块</p><p><strong>Requests库：网页抓取</strong></p><p>（查看爬虫协议：robots.txt，只有允许部分才可爬取）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(<span class="string">'&lt;网站名&gt;'</span>)</span><br><span class="line">r.status.code <span class="comment">#查看状态码</span></span><br><span class="line"><span class="comment">#若数据是二进制</span></span><br><span class="line">r.content</span><br><span class="line"><span class="comment">#若数据是js生成的</span></span><br><span class="line">r.json</span><br><span class="line">r.text</span><br><span class="line">r.encoding = <span class="string">''</span><span class="comment">#更改编码</span></span><br></pre></td></tr></table></figure><p>动态生成的页面可能无法使用requests</p><p><strong>网页数据解析</strong></p><p>（1）Beautifulsoup库：适用于有标签标记的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> Beautifulsoup</span><br><span class="line">markup = <span class="string">'&lt;字符串&gt;'</span><span class="comment">#记录标记</span></span><br><span class="line">soup = Beautifulsoup(markup,<span class="string">'lxml'</span>)<span class="comment">#</span></span><br><span class="line">soup.b<span class="comment">#对标签b类对象(tag)的访问</span></span><br><span class="line">soup.find_all(<span class="string">'b'</span>)<span class="comment">#可以找到所有被标签(tag)的内容，返回的是一个列表</span></span><br></pre></td></tr></table></figure><p>（2）re正则表达式模块处理：对于细则上比较复杂的数据提取</p><h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode_daily_practice(C++)</title>
      <link href="/2020/03/28/Leetcode-daily-practice/"/>
      <url>/2020/03/28/Leetcode-daily-practice/</url>
      
        <content type="html"><![CDATA[<h4 id="717-1比特和2比特字符"><a href="#717-1比特和2比特字符" class="headerlink" title="717.1比特和2比特字符"></a>717.1比特和2比特字符</h4><p>有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。</p><p>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 0, 0]</span><br><span class="line">输出: True</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 1, 1, 0]</span><br><span class="line">输出: False</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1 &lt;= len(bits) &lt;= 1000.`</p><p><code>bits[i] 总是0 或 1.</code></p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Judge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bits)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从倒数第二项开始，统计连续1的个数</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">bit</span>.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>( i &gt;= <span class="number">0</span> &amp;&amp; bits[i] == <span class="number">1</span>) i--;</span><br><span class="line">    <span class="comment">//若连续1的个数为奇数，则最后一项必然为2比特，否则为1比特</span></span><br><span class="line">    <span class="keyword">return</span> (bits.<span class="built_in">size</span>() - i)%<span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1386-两个数组间的距离值"><a href="#1386-两个数组间的距离值" class="headerlink" title="1386.两个数组间的距离值"></a>1386.两个数组间的距离值</h4><p>给你两个整数数组 <code>arr1</code> ， <code>arr2</code> 和一个整数 <code>d</code> ，请你返回两个数组之间的 <strong>距离值</strong> 。</p><p>「<strong>距离值</strong>」 定义为符合此描述的元素数目：对于元素 <code>arr1[i]</code> ，不存在任何元素 <code>arr2[j]</code> 满足 <code>|arr1[i]-arr2[j]| &lt;= d</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：arr1 &#x3D; [4,5,8], arr2 &#x3D; [10,9,1,8], d &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">对于 arr1[0]&#x3D;4 我们有：</span><br><span class="line">|4-10|&#x3D;6 &gt; d&#x3D;2 </span><br><span class="line">|4-9|&#x3D;5 &gt; d&#x3D;2 </span><br><span class="line">|4-1|&#x3D;3 &gt; d&#x3D;2 </span><br><span class="line">|4-8|&#x3D;4 &gt; d&#x3D;2 </span><br><span class="line">对于 arr1[1]&#x3D;5 我们有：</span><br><span class="line">|5-10|&#x3D;5 &gt; d&#x3D;2 </span><br><span class="line">|5-9|&#x3D;4 &gt; d&#x3D;2 </span><br><span class="line">|5-1|&#x3D;4 &gt; d&#x3D;2 </span><br><span class="line">|5-8|&#x3D;3 &gt; d&#x3D;2</span><br><span class="line">对于 arr1[2]&#x3D;8 我们有：</span><br><span class="line">|8-10|&#x3D;2 &lt;&#x3D; d&#x3D;2</span><br><span class="line">|8-9|&#x3D;1 &lt;&#x3D; d&#x3D;2</span><br><span class="line">|8-1|&#x3D;7 &gt; d&#x3D;2</span><br><span class="line">|8-8|&#x3D;0 &lt;&#x3D; d&#x3D;2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr1 &#x3D; [1,4,2,3], arr2 &#x3D; [-4,-3,6,10,20,30], d &#x3D; 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr1 &#x3D; [2,1,100,3], arr2 &#x3D; [-5,-2,10,-3,7], d &#x3D; 6</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr1.length, arr2.length &lt;= 500</code></li><li><code>-10^3 &lt;= arr1[i], arr2[j] &lt;= 10^3</code></li><li><code>0 &lt;= d &lt;= 100</code></li></ul><p><strong>算法1:线性扫描</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findthevalue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = arr1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr2.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(arr1[i] - arr[j]) &lt;= d)&#123;</span><br><span class="line">          cnt--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法2:二分查找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findthevalue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="comment">//对arr2进行排序，使用STL中的排序算法，之后即可使用二分法</span></span><br><span class="line">    sort(arr2.<span class="built_in">begin</span>(), arr2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> cnt = arr1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">      <span class="comment">//使用STL库中的二分查找,得到距离</span></span><br><span class="line">      <span class="comment">//复习lower_bound的参数（数组开始，数组末尾，查找元素）</span></span><br><span class="line">      <span class="comment">//运用unsigned型变量可以直接使用距离绝对值</span></span><br><span class="line">      <span class="keyword">unsigned</span> p = lower_bound(arr2.<span class="built_in">begin</span>(), arr2.<span class="built_in">end</span>(), arr1[i]) - arr2.<span class="built_in">begin</span>();</span><br><span class="line">      book ok = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">//下述步骤的学习需巩固lower_bound的相关特性。</span></span><br><span class="line">      <span class="comment">//如果能够在区间内找到接近的p值，则看最接近的值是否小于距离</span></span><br><span class="line">      <span class="keyword">if</span> (p &lt; arr2.<span class="built_in">size</span>()) ok &amp;= (arr2[p] - arr1[i] &gt; d);</span><br><span class="line">      <span class="comment">//如果p被截断，则直接看最大元素即可</span></span><br><span class="line">      <span class="keyword">if</span> (p - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; p - <span class="number">1</span> &lt;= arr2.<span class="built_in">size</span>()) ok &amp;= (arr[i] - arr[p - <span class="number">1</span>] &gt; d);</span><br><span class="line">      cnt += ok;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>STL：lower_bound算法（复杂度$O(n)$）</strong></p><p>（1）一共有三个参数：（开头，末尾，查找的值），可以用A.begin()和A.end()指定范围；</p><p>（2）返回值为<strong>不小于查找值</strong>的元素所在位置的编号（注意，编号从0开始）；否则越界截断；</p><p>（3）使用lower_bound算法需要注意两点：处理的数列已排序（sort算法），调用Algorithm库；</p><h4 id="997-找到小镇的法官"><a href="#997-找到小镇的法官" class="headerlink" title="997. 找到小镇的法官"></a>997. 找到小镇的法官</h4><p>在一个小镇里，按从 <code>1</code> 到 <code>N</code> 标记了 <code>N</code> 个人。传言称，这些人中有一个是小镇上的秘密法官。</p><p>如果小镇的法官真的存在，那么：</p><ol><li>小镇的法官不相信任何人。</li><li>每个人（除了小镇法官外）都信任小镇的法官。</li><li>只有一个人同时满足属性 1 和属性 2 。</li></ol><p>​        给定数组 <code>trust</code>，该数组由信任对 <code>trust[i] = [a, b]</code> 组成，表示标记为 <code>a</code> 的人信任标记为 <code>b</code> 的人。如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 <code>-1</code>。 </p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 2, trust &#x3D; [[1,2]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 3, trust &#x3D; [[1,3],[2,3]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 3, trust &#x3D; [[1,3],[2,3],[3,1]]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 3, trust &#x3D; [[1,2],[2,3]]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 4, trust &#x3D; [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= N &lt;= 1000</code></li><li><code>trust.length &lt;= 10000</code></li><li><code>trust[i]</code> 是完全不同的</li><li><code>trust[i][0] != trust[i][1]</code></li><li><code>1 &lt;= trust[i][0], trust[i][1] &lt;= N</code></li></ol><p><strong>代码（信任度与被信任度）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findthejudge</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trust)</span></span>&#123;</span><br><span class="line">    <span class="comment">//开辟一个二维数组存储信任度与被信任度</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">V</span><span class="params">(N+<span class="number">1</span>, <span class="built_in">vector</span>(<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trust.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">      V[trust[i][<span class="number">0</span>]][<span class="number">0</span>]++;</span><br><span class="line">      V[trust[i][<span class="number">1</span>]][<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span> (V[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; V[i][<span class="number">1</span>] == N<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：vector的相关用法</strong></p><h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h4><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="built_in">size</span>;<span class="comment">//N为对应的二进制数，代表总的子集数目</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">size</span>; ++j)&#123;<span class="comment">//遍历，判断相应情况下取或者不取</span></span><br><span class="line">        <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j))&#123;<span class="comment">//i的二进制表示其实就是取或者不取的含义</span></span><br><span class="line">          v.push_back(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ans.push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*代码说明：</span></span><br><span class="line"><span class="comment">a &lt;&lt; b表示把a转为二进制后左移b位；</span></span><br><span class="line"><span class="comment">a &gt;&gt; b表示把a转为二进制后右移动b位；</span></span><br><span class="line"><span class="comment">&amp;运算通常用作取位操作，取二者相同的位置；</span></span><br><span class="line"><span class="comment">事实上，位运算就是把数字转化为二进制后进行操作，但存储的变量本质上仍然是十进制</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h4><p>根据每日 <code>气温</code> 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p><strong>提示：</strong><code>气温</code> 列表长度的范围是 <code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在 <code>[30, 100]</code> 范围内的整数。</p><p><strong>思路</strong></p><p>这道题最容易想到的方法就是做一个二重循环，依次找到每个温度后的最大上升天数，但很显然，时间复杂度为$O(n^2)$，很容易就超时了。</p><p>此时可以考虑使用单调栈。单调栈是一种专门对数组进行排序的数据结构，时间复杂度为$O(n)$。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>:</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = T.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="built_in">size</span>,<span class="number">0</span>)</span></span>;<span class="comment">//开辟一个长度为size的数组，初始化为0</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; res;<span class="comment">//设计一个栈，用于判断数值大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span> (res.empty()) res.push(i);<span class="comment">//如果栈为空，则放入当前元素，此处操作为防止越界问题</span></span><br><span class="line">      <span class="keyword">while</span> (!res.empty() &amp;&amp; T[j] &gt; T[res.top()])&#123; </span><br><span class="line">        ans[res.top()] = i - res.top();</span><br><span class="line">        res.pop();</span><br><span class="line">      &#125;<span class="comment">//若当前元素大于栈顶，则计算距离并存储，后去掉栈顶，继续判断</span></span><br><span class="line">      res.push(i);<span class="comment">//完成上述操作后，说明当前元素小于栈中所有元素，故将此时的元素放入栈中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h4><p>给定一个包含 <em>n</em> + 1 个整数的数组 <em>nums</em>，其数字都在 1 到 <em>n</em> 之间（包括 1 和 <em>n</em>），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li><strong>不能</strong>更改原数组（假设数组是只读的）。</li><li>只能使用额外的$ O(1) $的空间。</li><li>时间复杂度小于 $O(n^2)$ 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ol><p><strong>解决方案</strong></p><p>最容易考虑的思路是先排序，之后再遍历一遍看是否存在重复元素。但在不允许更改原数组的情形下，无法满足上述空间限制，则需要考虑新的方法。事实上，本题目存在一种特殊方法：<strong>循环检测方法</strong></p><p>考虑索引，用nums[i]表示i下一步的方向（能够保证上述操作进行的条件就是整数分布在1到n之间）；由此会发现若存在重复数，那么最后无法到达n，会导致循环的出现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> quick = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">      slow = nums[slow];</span><br><span class="line">      quick = nums[nums[quick]];</span><br><span class="line">    &#125;<span class="keyword">while</span>(slow != quick);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ptr_1 = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> ptr_2 = slow;</span><br><span class="line">    <span class="keyword">while</span>(ptr_1 != ptr_2)&#123;</span><br><span class="line">      ptr_1 = nums[ptr_1];</span><br><span class="line">      ptr_2 = nums[ptr_2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr_1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二分查找</strong></p><p>由于题目给定了数组中数字范围，即1到n，则最终的答案也在二者之中；可以考虑使用二分法，依次考虑小于mid的数字的出现的次数，若比较大， 则再做一次二分查找，最后即可以找到目标值;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = nums.length;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//二分查找基本思路</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= mid) cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (cnt &gt; mid)&#123;</span><br><span class="line">        r = mid;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h4><p>给定一个 <em>m</em> x <em>n</em> 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用<strong><a href="http://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong>算法<strong>。</strong></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,1]</span><br><span class="line">]</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><ul><li>一个直接的解决方案是使用  O(<em>m**n</em>) 的额外空间，但这并不是一个好的解决方案。</li><li>一个简单的改进方案是使用 O(<em>m</em> + <em>n</em>) 的额外空间，但这仍然不是最好的解决方案。</li><li>你能想出一个常数空间的解决方案吗？</li></ul><p><strong>我的思路</strong></p><p>设置两个空数组用于存储行列指标，之后再做处理；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>||n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; label_i, label_j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">          label_i.push_back(i);</span><br><span class="line">          label_j.push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = label_i.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; ++K)&#123;</span><br><span class="line">      <span class="keyword">int</span> tmpi = label_i[k], tmpj = label_j[k];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) matrix[i][tmpj] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) matrix[tmpi][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a>994. 腐烂的橘子</h4><p>在给定的网格中，每个单元格可以有以下三个值之一：</p><ul><li>值 <code>0</code> 代表空单元格；</li><li>值 <code>1</code> 代表新鲜橘子；</li><li>值 <code>2</code> 代表腐烂的橘子。</li></ul><p>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p><p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code>。</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[0,2]]</span><br><span class="line">输出：0</span><br><span class="line">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= grid.length &lt;= 10</code></li><li><code>1 &lt;= grid[0].length &lt;= 10</code></li><li><code>grid[i][j]</code> 仅为 <code>0</code>、<code>1</code> 或 <code>2</code></li></ol><h4 id="1227-飞机座位分配概率（动态规划）"><a href="#1227-飞机座位分配概率（动态规划）" class="headerlink" title="1227. 飞机座位分配概率（动态规划）"></a>1227. 飞机座位分配概率（动态规划）</h4><p>有 <code>n</code> 位乘客即将登机，飞机正好有 <code>n</code> 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。</p><p>剩下的乘客将会：</p><ul><li>如果他们自己的座位还空着，就坐到自己的座位上，</li><li>当他们自己的座位被占用时，随机选择其他座位</li></ul><p>第 <code>n</code> 位乘客坐在自己的座位上的概率是多少？</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：1.00000</span><br><span class="line">解释：第一个人只会坐在自己的位置上。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 2</span><br><span class="line">输出: 0.50000</span><br><span class="line">解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li></ul><p><strong>参考解答</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)第一位乘客若选择了本就是其自己的位置，则后面的人都会按顺序入座，第n位乘客入座概率为1&#x2F;n;</span><br><span class="line">(2)第一位乘客刚好选择了第n位乘客的位置，则第n位乘客成功入学概率为0；</span><br><span class="line">(3)第一位乘客选择了第i位乘客(i不为0或1)的座位，则可把第i位乘客看作忘带票乘客选择n-1个座位，写出递推公式；</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">f(n) = \frac{1}{n} +\frac{n-2}{n}f(n-1)</script><h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a>236.二叉树的最近公共祖先</h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉树中。</p><p><strong>思路</strong></p><p>p和q的分布存在两种情况，在同一侧或者不同侧中，则考虑对左右子树分别进行递归操作；</p><p>递归的返回条件为root为空或者root为p或者q中一个；</p><p>之后判断：若左右子树均有返回值，则说明存在于左右子树中，返回当前节点；反之，则非空返回结点为公共节点；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  TreeNode* left;</span><br><span class="line">  TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//若root为空或者等于p或者q中的一个，则返回root</span></span><br><span class="line">    <span class="keyword">if</span> (!root || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">//查询左子树和右子树</span></span><br><span class="line">    TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    <span class="comment">//若左右均有返回值，则说明p,q位于两侧，直接返回此时的根节点</span></span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">//若只有一侧有返回值，则返回此时非空变量即可</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> left?left: right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1319-连通网络的操作次数"><a href="#1319-连通网络的操作次数" class="headerlink" title="1319. 连通网络的操作次数"></a>1319. 连通网络的操作次数</h4><p>用以太网线缆将 <code>n</code> 台计算机连接成一个网络，计算机的编号从 <code>0</code> 到 <code>n-1</code>。线缆用 <code>connections</code> 表示，其中 <code>connections[i] = [a, b]</code> 连接了计算机 <code>a</code> 和 <code>b</code>。</p><p>网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。</p><p>给你这个计算机网络的初始布线 <code>connections</code>，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 </p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_1_1677.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 4, connections &#x3D; [[0,1],[0,2],[1,2]]</span><br><span class="line">输出：1</span><br><span class="line">解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_2_1677.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 6, connections &#x3D; [[0,1],[0,2],[0,3],[1,2],[1,3]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 6, connections &#x3D; [[0,1],[0,2],[0,3],[1,2]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：线缆数量不足。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 5, connections &#x3D; [[0,1],[0,2],[3,4],[2,3]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= connections.length &lt;= min(n*(n-1)/2, 10^5)</code></li><li><code>connections[i].length == 2</code></li><li><code>0 &lt;= connections[i][0], connections[i][1] &lt; n</code></li><li><code>connections[i][0] != connections[i][1]</code></li><li>没有重复的连接。</li><li>两台计算机不会通过多条线缆连接。</li></ul><h4 id="1038-从二叉搜索树到更大和树"><a href="#1038-从二叉搜索树到更大和树" class="headerlink" title="1038. 从二叉搜索树到更大和树"></a>1038. 从二叉搜索树到更大和树</h4><p>难度中等46收藏分享切换为英文关注反馈</p><p>给出二叉 <strong>搜索</strong> 树的根节点，该二叉树的节点值各不相同，修改二叉树，使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>示例：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>树中的节点数介于 <code>1</code> 和 <code>100</code> 之间。</li><li>每个节点的值介于 <code>0</code> 和 <code>100</code> 之间。</li><li>给定的树为二叉搜索树。</li></ol><p><strong>解题思路</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二叉搜索树最重要的性质便是右侧的数值大于左侧，本题中替换的数值大小便是右侧的所有键值之和。</span><br><span class="line">采取左序遍历的方式，求出所有元素之和，再依次减去自身元素即可；</span><br></pre></td></tr></table></figure><p><strong>参考代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  TreeNode* left;</span><br><span class="line">  TreeNode* right;</span><br><span class="line">  TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>:</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">sum_num</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(root)&#123;</span><br><span class="line">       sum_num(root-&gt;left);</span><br><span class="line">       sum += root-&gt;val;</span><br><span class="line">       qu.push(root-&gt;val);</span><br><span class="line">       sum_num(root-&gt;right);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">insertval</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(root)&#123;</span><br><span class="line">       insertval(root-&gt;left);</span><br><span class="line">       root-&gt;val = sum;</span><br><span class="line">       sum -= qu.front();</span><br><span class="line">       qu.pop();</span><br><span class="line">       insertval(root-&gt;right);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">TreeNode* <span class="title">bstToGst</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">     sum_num(root);</span><br><span class="line">     insertval(root);</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="50-利用快速幂算法实现pow-x-n-函数"><a href="#50-利用快速幂算法实现pow-x-n-函数" class="headerlink" title="50.利用快速幂算法实现pow(x,n)函数"></a>50.利用快速幂算法实现pow(x,n)函数</h4><p>基本思路，采用递归的想法，将$x^n$看作$(x^{n/2})^2$即可（快速幂算法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">FastPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">double</span> half = FastPow(x, n/<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> half*half;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> half*half*x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    x = <span class="number">1</span>/x;</span><br><span class="line">    n = -n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> FastPow(x,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h4><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>对于层序遍历，最开始想到的便是借助队列使用宽度有限搜索的方法</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>:</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ans</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class="line">    qu.push_back(root);</span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;<span class="comment">//开启新的一层</span></span><br><span class="line">      <span class="keyword">int</span> n = qu.<span class="built_in">size</span>();<span class="comment">//现存的队列长度为该层的元素个数</span></span><br><span class="line">      <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        TreeNode* t = qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line">        tmp.push_back(t-&gt;val);</span><br><span class="line">        <span class="comment">//放入非空的结点</span></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;left != <span class="literal">NULL</span>) qu.push(t-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;right != <span class="literal">NULL</span>) qu.push(t-&gt;right);</span><br><span class="line">        n--;</span><br><span class="line">      &#125;</span><br><span class="line">      ans.push_back(tmp);<span class="comment">//算好一层后放入一层</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;<span class="comment">//返回层序遍历结果</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h4><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 <strong>-1</strong>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <a href="https://baike.baidu.com/item/strstr/811469" target="_blank" rel="noopener">strstr()</a> 以及 Java的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String" target="_blank" rel="noopener">indexOf()</a>) 定义相符。</p><p><strong>解题思路</strong></p><p>方法一、使用#include<cstring>中的find函数，如果找到needle，则返回起点；若无法找到needle，则返回haystack.npos，只需判断返回值即可。（但这种方法比较偷懒，没啥价值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用cstring库</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> <span class="built_in">text</span>, <span class="built_in">string</span> pattern)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">text</span>.<span class="built_in">find</span>(pattern) == <span class="built_in">text</span>.npos) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">text</span>.<span class="built_in">find</span>(pattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二、Brute-Force算法：暴力求解，从头到尾遍历一遍，遇见不相等则跳过；</p><p>方法三、优化Brute-Force：“减少爬行趟数”——跳过不可能的那部分字符串</p><p>（1）pattern构造next数组：next[i] 表示 0 ~ i 这一个子串，使得<strong>前k个字符</strong>恰好等于<strong>后k个字符</strong>的最大的k；</p><p><em>如果失配在 P[r], 那么P[0]~P[r-1]这一段里面，<strong>前next[r-1]个字符恰好和后next[r-1]个字符相等</strong>——也就是说，我们可以拿长度为 next[r-1] 的那一段前缀，来顶替当前后缀的位置，让匹配继续下去！</em></p><p><strong>KMP算法的精髓：快速求next数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设计双指针，一个表示前序，一个表示后序</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(pattern.<span class="built_in">size</span>() + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">-1</span>, i = <span class="number">0</span>;</span><br><span class="line">next[i] = j;<span class="comment">//对于第一个元素，只能满足前-1个元素</span></span><br><span class="line"><span class="comment">//利用i 指针进行遍历</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; pattern.<span class="built_in">size</span>())&#123;</span><br><span class="line">  <span class="comment">//当无法匹配时，则j自动跳至next[j]指的位置进行判定</span></span><br><span class="line">  <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; pattern[i] != pattern[j]) j = next[j];</span><br><span class="line">  i++, j++;</span><br><span class="line">  b[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过建立next数组，可以快速得到每次需要跳过的步骤</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> <span class="built_in">text</span>, <span class="built_in">string</span> pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pattern.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">text</span>.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//构造next数组，i为沿着pattern前进的指针，j为计数器</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(pattern.<span class="built_in">size</span>() + <span class="number">1</span>)</span></span>;</span><br><span class="line">    next[i] = j;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; pattern.<span class="built_in">size</span>())&#123;</span><br><span class="line">      <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; pattern[i] != pattern[j]) j = b[j];</span><br><span class="line">      i++, j++;</span><br><span class="line">      next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始对两个数组进行匹配判断，i沿着pattern前进，j沿着text前进</span></span><br><span class="line">    j = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; <span class="built_in">text</span>.<span class="built_in">size</span>())&#123;</span><br><span class="line">      <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; pattern[i] != <span class="built_in">text</span>[j]) i = b[i];</span><br><span class="line">      i++, j++;</span><br><span class="line">      <span class="keyword">if</span>(i == pattern.<span class="built_in">size</span>()) <span class="keyword">return</span> j - pattern.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 代码训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="第一阶段（3月28日至正式开学）"><a href="#第一阶段（3月28日至正式开学）" class="headerlink" title="第一阶段（3月28日至正式开学）"></a>第一阶段（3月28日至正式开学）</h1><p>教材：《挑战程序设计竞赛2：算法和数据结构》</p><h3 id="第0部分：基本数据结构"><a href="#第0部分：基本数据结构" class="headerlink" title="第0部分：基本数据结构"></a>第0部分：基本数据结构</h3><h4 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h4><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h3 id="第一部分：排序"><a href="#第一部分：排序" class="headerlink" title="第一部分：排序"></a>第一部分：排序</h3><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h4 id="归并排序：时间复杂度-O-n-log-n"><a href="#归并排序：时间复杂度-O-n-log-n" class="headerlink" title="归并排序：时间复杂度$O(n\log n)$"></a>归并排序：时间复杂度$O(n\log n)$</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SENTIVITY 1000000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L[MAX/<span class="number">2</span>+<span class="number">1</span>],R[MAX/<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = mid - left;</span><br><span class="line">    <span class="keyword">int</span> n2 = right - mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; ++i) L[i] = A[left + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; ++j) R[j] = A[mid + j];<span class="comment">//开辟两个独立数组，存储数据</span></span><br><span class="line">    L[n1] = R[n2] = SENTIVITY;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt; right; ++k)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j])&#123;</span><br><span class="line">            A[k] = L[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            A[k] = R[j++];</span><br><span class="line">        &#125;<span class="comment">//数据按照大小依次插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left+<span class="number">1</span> &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        mergesort(A, n, left, mid);<span class="comment">//前半部分排序</span></span><br><span class="line">        mergesort(A, n, mid, right);<span class="comment">//后半部分排序</span></span><br><span class="line">        merge(A, n, left, mid, right);<span class="comment">//融合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[MAX], n, i;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mergesort(A, n, <span class="number">0</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,A[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序：时间复杂度-O-n-log-n"><a href="#快速排序：时间复杂度-O-n-log-n" class="headerlink" title="快速排序：时间复杂度$O(n\log n)$"></a>快速排序：时间复杂度$O(n\log n)$</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;分割算法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;快排算法</span><br><span class="line">quickSort(A,p,r)</span><br><span class="line">    if p&lt;r</span><br><span class="line">         q&#x3D;partition(A,p,r)</span><br><span class="line">         quicksort(A,p,q-1)</span><br><span class="line">         quicksort(A,q+1,r)</span><br></pre></td></tr></table></figure><p>STL的Algorithm库中使用的也是快速排序算法，但快速排序本身是一种不稳定的算法。</p><h4 id="逆序数问题"><a href="#逆序数问题" class="headerlink" title="逆序数问题"></a>逆序数问题</h4><p>（1）基于冒泡排序实现：简单但时间复杂度高$O(n^2)$;</p><p>（2）基于归并排序实现：用到分治策略，时间复杂度$O(n\log n)$;</p><h4 id="最小成本排序问题（考虑到单次操作的权重）"><a href="#最小成本排序问题（考虑到单次操作的权重）" class="headerlink" title="最小成本排序问题（考虑到单次操作的权重）"></a>最小成本排序问题（考虑到单次操作的权重）</h4><h3 id="第二部分：数"><a href="#第二部分：数" class="headerlink" title="第二部分：数"></a>第二部分：数</h3><h4 id="第八章：树"><a href="#第八章：树" class="headerlink" title="第八章：树"></a>第八章：树</h4><p><strong>基本概念</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">根（root）：没有父结点的结点；</span><br><span class="line">叶（leaf）：没有子结点的结点；</span><br><span class="line">内部结点：既不是根，也不是叶的结点；</span><br><span class="line">度（degree）：某一结点拥有的字结点的数目；</span><br><span class="line">深度（depth）：从根到结点的路径长度；</span><br><span class="line">有根二叉树：有根结点，且所有结点的度均不超过2；（根&#x2F;左二叉树&#x2F;右二叉树）</span><br></pre></td></tr></table></figure><p><strong>有根树的实现</strong></p><p>在C++语言中，可以使用结构体表达（左子右兄弟表示法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> parent, left, right&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">T</span>[<span class="title">MAX</span>];</span></span><br></pre></td></tr></table></figure><p>利用递归求深度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDepth</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    D[u] = p;<span class="comment">//给u结点设置为深度p（相当于设置一个起始结点）；</span></span><br><span class="line">    <span class="keyword">if</span> (T[u].r != NIL) setDepth(T(u).r, p);<span class="comment">//右兄弟：结点深度一致；</span></span><br><span class="line">    <span class="keyword">if</span> (T[u].l != NIL) setDepth(T(u).l, p+<span class="number">1</span>);<span class="comment">//左子：结点深度加一；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二叉树的表达</strong></p><p>结点用结构体表达</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> parent, left, right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二叉树的输入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123; <span class="comment">//n表示所有结点的总数目</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;v, &amp;l, &amp;r);</span><br><span class="line">  T[v].left = l;<span class="comment">//设置子结点</span></span><br><span class="line">  T[v].right = r;</span><br><span class="line">  <span class="keyword">if</span> (l != NIL) T[l].parent = v;<span class="comment">//设置父结点</span></span><br><span class="line">  <span class="keyword">if</span> (r != NIL) T[r].parent = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结点的深度利用递归方法求解（自顶向下）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDepth</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == NIL) <span class="keyword">return</span>;<span class="comment">//对于异常值，表示结束</span></span><br><span class="line">    D[u] = p;<span class="comment">//给u结点设置为深度p（相当于设置一个起始结点）；</span></span><br><span class="line">    <span class="keyword">if</span> (T[u].r != NIL) setDepth(T(u).right, p+<span class="number">1</span>);<span class="comment">//右子：结点深度加一；</span></span><br><span class="line">    <span class="keyword">if</span> (T[u].l != NIL) setDepth(T(u).left, p+<span class="number">1</span>);<span class="comment">//左子：结点深度加一；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树的高度递归法求解（自底向上）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;<span class="comment">//初始化变量</span></span><br><span class="line">  <span class="keyword">if</span> (T[u].left != NIL)</span><br><span class="line">    h1 = setHeight(T[u].left) + <span class="number">1</span>;<span class="comment">//左结点的高度基础上加一</span></span><br><span class="line">  <span class="keyword">if</span> (T[u].left != NIL)</span><br><span class="line">    h2 = setHeight(T[u].right) + <span class="number">1</span>;<span class="comment">//右结点的高度基础上加一</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(h1, h2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>树的遍历</strong></p><p>前序遍历：根节点、左子树、右子树的顺序输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preParse</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (u == NIL) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, u);</span><br><span class="line">  preParse(T[u].left);</span><br><span class="line">  preParse(T[u].right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：左子树、根节点、右子树的顺序输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (u == NIL) <span class="keyword">return</span>;</span><br><span class="line">  inorder(T[u].left);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, u);</span><br><span class="line">  inorder(T[u].right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：左子树、右子树、根节点的顺序输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (u == NIL) <span class="keyword">return</span>;</span><br><span class="line">  postorder(T[u].left);</span><br><span class="line">  postorder(T[u].right);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题：根据前序遍历和中序遍历的结果重建树</strong></p><p>前序遍历的第一个元素为根结点，找到其在中序遍历中的位置，分离出左右子树，之后做递归处理；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, pos;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, in, post;<span class="comment">//用来存储前序遍历、中序遍历、后序遍历的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用递归的思想处理左右子树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> root = pre[pos++];</span><br><span class="line">  <span class="comment">//利用find函数在inorder中找到根结点，之后分割出左右子树</span></span><br><span class="line">  <span class="keyword">int</span> m = distance(in.<span class="built_in">begin</span>(), <span class="built_in">find</span>(in.<span class="built_in">begin</span>(), in.<span class="built_in">end</span>(), root));</span><br><span class="line">  rec(l, m); <span class="comment">//处理左子树</span></span><br><span class="line">  rec(m + <span class="number">1</span>, r); <span class="comment">//处理右子树</span></span><br><span class="line">  post.push_back(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将处理好后的后序遍历输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  pos = <span class="number">0</span>;</span><br><span class="line">  rec(<span class="number">0</span>, pre.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (i) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, post[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"/n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="comment">//输入前序遍历数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    pre.push_back(k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//输入中序遍历数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    in.push_back(m);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//输出后序遍历结果</span></span><br><span class="line">  solve();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">事实上，只要知道其中任意两种遍历结果，皆可重建第三种遍历结果；</span><br><span class="line">（1）已知中序，后序：后序的最后一个结点为根结点——在中序中可以分为左子树、右子树，从而递归处理；</span><br><span class="line">（2）已知前序遍历和后序遍历，无法唯一确定中序遍历；</span><br></pre></td></tr></table></figure><h4 id="第九章：二叉搜索树（使用指针）"><a href="#第九章：二叉搜索树（使用指针）" class="headerlink" title="第九章：二叉搜索树（使用指针）"></a>第九章：二叉搜索树（使用指针）</h4><p>设$x$为二叉搜索树的结点。如果$y$为$x$左子树中的结点，$z$为$x$右子树中的结点，则有$y\le x\le z$。如果对二叉搜索树做中序遍历，会得到一个升序的键值序列。（类似于二分法）</p><p>使用二叉树存储数据相对于使用列表时间复杂度更低，但实际结构较为复杂。</p><p><strong>二叉搜索树的结点</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> key;<span class="comment">//此处结点的键值</span></span><br><span class="line">  Node *parent, *left, *right;<span class="comment">//指向父结点与子结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><p>从根开始，比较键值大小，大的向右搜索，小的向左搜索，从而找到空结点拓宽；时间复杂度$O(h)=O(\log n)$.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  <span class="keyword">int</span> *parent, *left, *right;</span><br><span class="line">&#125;;<span class="comment">//设置结点变量</span></span><br><span class="line"></span><br><span class="line">Node *root, *NIL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//插入操作</span></span><br><span class="line">  Node *y = NIL;</span><br><span class="line">  Node *x = root;</span><br><span class="line">  Node *z;</span><br><span class="line">  <span class="comment">//初始化Z变量，用于临时存储</span></span><br><span class="line">  z = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">  z-&gt;key = k;</span><br><span class="line">  z-&gt;left = NIL;</span><br><span class="line">  z-&gt;right = NIL;</span><br><span class="line">  <span class="comment">//通过x变量循环寻找合适的位置</span></span><br><span class="line">  <span class="keyword">while</span>(x != NIL)&#123;</span><br><span class="line">    y = x;</span><br><span class="line">    <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key)&#123;</span><br><span class="line">      x = x-&gt;left;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//y变量用于作为z所在的父结点</span></span><br><span class="line">  z-&gt;parent = y;</span><br><span class="line">  <span class="keyword">if</span> (y == NIL)&#123;</span><br><span class="line">    root = z;<span class="comment">//判断z是否是第一个结点</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key)&#123;</span><br><span class="line">      y-&gt;left = z;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      y-&gt;right = z;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node *u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (u = NIL) <span class="keyword">return</span>;</span><br><span class="line">  inorder(u-&gt;left);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, u-&gt;key);</span><br><span class="line">  inorder(u-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(Node *u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (u == NIL) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, u-&gt;key);</span><br><span class="line">  preorder(u-&gt;left);</span><br><span class="line">  preorder(u-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">string</span> com;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; com;</span><br><span class="line">    <span class="keyword">if</span> (com = <span class="string">"insert"</span>)&#123;<span class="comment">//判断操作；输入</span></span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">      insert(x);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(com = <span class="string">"print"</span>)&#123;<span class="comment">//判断操作：输出</span></span><br><span class="line">      inorder(root);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">      preorder(root);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>搜索</strong>：时间复杂度$O(h)=O(\log n)$.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">find</span><span class="params">(Node *u, <span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//在u为根节点的这棵树中寻找k是否存在</span></span><br><span class="line">  <span class="keyword">while</span>(u != NIL &amp;&amp; k != u-&gt;key)&#123; <span class="comment">//u非空且未找到k值</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; u-&gt;key) u = u-&gt;left;</span><br><span class="line">    <span class="keyword">else</span> u = u-&gt;right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除</strong>：时间复杂度$O(h)=O(\log n)$。难点在于，删除后如何<strong>保证二叉树的基本性质</strong>。</p><p>一共有三种情况需要考虑：无结点、一结点、两结点</p><p>（1）$z$没有子结点，需要删除其父结点的子结点；</p><p>（2）$z$拥有一个子结点时，将其父结点的子结点更新为该子结点，同时该子结点变换为父结点；</p><p>（3）$z$有两个子结点时，将$z$的后一个结点$y$的键值复制到$z$，然后删除$y$。注意，此处的“后一个结点”指的是中序遍历时排在后面的那一个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到树中最小的元素</span></span><br><span class="line"><span class="function">Node * <span class="title">treeMinimum</span><span class="params">(Node *x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(x-&gt;left != NIL) x = x-&gt;left;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算后一个结点的算法</span></span><br><span class="line"><span class="function">Node * <span class="title">treeSuccessor</span><span class="params">(Node *x)</span></span>&#123;</span><br><span class="line">  <span class="comment">//存在右子树时，最小值即是需删除的结点</span></span><br><span class="line">  <span class="keyword">if</span> (x-&gt;right != NIL) </span><br><span class="line">    <span class="keyword">return</span> treeMinimum(x-&gt;right);</span><br><span class="line">  <span class="comment">//不存在右子结点时，要向上查询</span></span><br><span class="line">  Node *y = x-&gt;parent;</span><br><span class="line">  <span class="keyword">while</span>(y != NIL &amp;&amp; x == y-&gt;right)&#123;<span class="comment">//当查到为右子树时才为后一个结点</span></span><br><span class="line">    x = y;</span><br><span class="line">    y = y-&gt;parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treedelete</span><span class="params">(Node *z)</span></span>&#123;</span><br><span class="line">  Node *y;<span class="comment">//删除的对象</span></span><br><span class="line">  Node *x;<span class="comment">//y的子结点</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//确定删除的结点</span></span><br><span class="line">  <span class="comment">//无结点或者只有一个结点时，y就是需要删除的对象</span></span><br><span class="line">  <span class="keyword">if</span>(z-&gt;left == NIL || z-&gt;right == NIL) y = z;</span><br><span class="line">  <span class="comment">//有两个结点时</span></span><br><span class="line">  <span class="keyword">else</span> y = treeSuccessor(z);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//确定y的子结点x</span></span><br><span class="line">  <span class="keyword">if</span> (y -&gt; left != NIL)&#123;</span><br><span class="line">    x = y-&gt;left;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    x = y-&gt;right;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (x != NIL)&#123;</span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (y-&gt;parent = NIL)&#123;<span class="comment">//如果删除的是根结点</span></span><br><span class="line">    root = x;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == y-&gt;parent-&gt;left)&#123;<span class="comment">//判断是左结点还是右结点</span></span><br><span class="line">      y-&gt;parent-&gt;left = x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      y-&gt;parent-&gt;right = x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (y != z)&#123;</span><br><span class="line">    z-&gt;key = y-&gt;key;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用STL标准库管理集合</strong></p><p>（1）序列式容器：新添加的元素置于特定位置，如vector, list两种。</p><p>（2）关联式容器：依据特定的排序标准来确定存储位置。其中，set由二叉搜索树实现，能够保持搜索、插入、删除的时间复杂度为$O(\log n)$；map也是基于平衡二叉搜索树实现，但存储方式不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.set：根据元素值进行排序的集合，元素唯一不重复；可使用迭代器顺次访问各元素。需事先声明#include&lt;set&gt;; 初始化变量操作举例 set&lt;int&gt; S;</span><br><span class="line">size()  返回set中元素个数； </span><br><span class="line">clear() 清空整个set；</span><br><span class="line">begin() 指向set开头的迭代器； </span><br><span class="line">end()   指向set末尾的迭代器；</span><br><span class="line">insert(key)  插入元素key;</span><br><span class="line">erase(key)   删除元素key;</span><br><span class="line">find(key)    查询元素key,如果有相同的则返回该元素的迭代器，否则指向末尾end();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.map：每个元素拥有一个键与值，集合以键作为排序标准。元素唯一不重复，可用于实现“从字符串中删除字符串”这一类字典功能；需事先声明#include&lt;map&gt;，初始化举例map&lt;string,int&gt; T;</span><br><span class="line">size() 返回map中的元素个数；</span><br><span class="line">clear() 清除map中所有元素；</span><br><span class="line">begin() 返回指向map开头的迭代器；</span><br><span class="line">end() 返回指向map末尾的迭代器；</span><br><span class="line">insert((key,val)) 插入元素（key,val），分别指代具体存储内容和相对应赋予的值。</span><br><span class="line">erase(key) 删除值为key的元素；</span><br><span class="line">find(key)  查询元素key,如果有相同的则返回该元素的迭代器，否则指向末尾end();</span><br></pre></td></tr></table></figure><h4 id="第十章：堆"><a href="#第十章：堆" class="headerlink" title="第十章：堆"></a>第十章：堆</h4><p>（1）完全二叉树；所有叶结点深度相同，且所有内部结点都有两个子结点；</p><p>（2）近似完全二叉树：叶深度最大差距为1，最下层叶结点位于最左边的若干位置上；</p><p>（3）对于存储$n$个元素的完全二叉树，其树高为$\log_2 n$；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">二叉堆：</span><br><span class="line">（1）逻辑结构为完全二叉树，但事实上用一位数组存储数据，通过下标进行管理</span><br><span class="line">（2）对于下标为i的结点——父结点：i&#x2F;2；左结点：2i；右结点：2i+1；</span><br><span class="line">（3）最大堆：结点的键值小于父结点的键值；最小堆：结点的键值小于父结点的键值；</span><br></pre></td></tr></table></figure><p><strong>代码：生成最大堆</strong>（时间复杂度$O(H)$）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 2000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> H, A[MAX+<span class="number">1</span>];<span class="comment">//H是数组长度，A代表数组。（对于未知长度数组可以使用vector）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l, r, largest;</span><br><span class="line">  l = <span class="number">2</span> * i;<span class="comment">//左结点</span></span><br><span class="line">  r = <span class="number">2</span> * i + <span class="number">1</span>;<span class="comment">//右结点</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//找出左右结点中较大的一个</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= H &amp;&amp; A[l] &gt; A[i]) largest = l;</span><br><span class="line">  <span class="keyword">else</span> largest = i;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= H &amp;&amp; A[r] &gt; A[largest]) largest = r;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//将当前结点与较大的一个交换，同时循环进行；</span></span><br><span class="line">  <span class="keyword">if</span> (largest != i)&#123;</span><br><span class="line">    swap(A[i], A[largest]);<span class="comment">//交换两个函数的值</span></span><br><span class="line">    maxHeapify(largest);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;H);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= H; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = H/<span class="number">2</span>; i &gt;= i; --i) maxHeapify(i);<span class="comment">//以2/H为起点，1位终点，自底向上交换</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= H; ++i) <span class="built_in">printf</span>(<span class="string">"%d"</span>, A[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">从底层开始对某一结点做最大堆处理，之后遍历全体。</span><br></pre></td></tr></table></figure><p><strong>优先级队列：优先取出最大键值的队列</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 2000000<span class="comment">//数组最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFTY(1 &lt;&lt; 32)<span class="comment">//（复习一下位运算）</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> H, A[MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="comment">//参见上一小节</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除最大键值的操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extract</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> maxv;</span><br><span class="line">  <span class="keyword">if</span> (H &lt; <span class="number">1</span>) <span class="keyword">return</span> -INFTY;<span class="comment">//特殊情况，队列为0时无法删除</span></span><br><span class="line">  maxv = A[<span class="number">1</span>];</span><br><span class="line">  A[<span class="number">1</span>] = A[H];<span class="comment">//最小元素放在最前方</span></span><br><span class="line">  H--;<span class="comment">//队列长度减一</span></span><br><span class="line">  maxHeapify(<span class="number">1</span>);<span class="comment">//重新生成最大堆</span></span><br><span class="line">  <span class="keyword">return</span> maxv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increaseKey</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key &lt; A[i]) <span class="keyword">return</span>;</span><br><span class="line">  A[i] = key;</span><br><span class="line">  <span class="keyword">while</span>(i &gt; <span class="number">1</span> &amp;&amp; A[i/<span class="number">2</span>] &lt; A[i])&#123;</span><br><span class="line">    swap(A[i], A[i/<span class="number">2</span>]);</span><br><span class="line">    i = i/<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">  H++;</span><br><span class="line">  A[H] = -INFTY;</span><br><span class="line">  increaseKey(H, key);</span><br><span class="line">  <span class="comment">//把元素添加至末尾后，在自底向上循环判断其应所处位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用STL库实现优先级队列：priority_queue</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）push()：向队列中插入一个元素；</span><br><span class="line">（2）top(): 访问队列中的开头元素；</span><br><span class="line">（3）pop(): 用于删除队列中的开头元素；</span><br><span class="line">值得说明的是，在priority_queue中，开头元素永远是拥有最大优先级的元素；优先级可以由程序员确定，但默认int型数据中最大的元素优先级最高。</span><br></pre></td></tr></table></figure><h4 id="第十一章：动态规划法"><a href="#第十一章：动态规划法" class="headerlink" title="第十一章：动态规划法"></a>第十一章：动态规划法</h4><p>基本概念：对已有的计算结果记忆化，方便直接调用，避免重复计算；用空间换取时间的策略；</p><p><strong>例子：斐波拉契数列</strong>：使用数组存储每一次的计算结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; F;</span><br><span class="line">    F.push_back(<span class="number">1</span>);</span><br><span class="line">    F.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        F.push_back(F[i<span class="number">-1</span>]+F[i<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, F[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子：求最长公共子序列</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="built_in">string</span> X, <span class="built_in">string</span> Y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c[N+<span class="number">1</span>][N+<span class="number">1</span>];<span class="comment">//开辟二维数组计算已有计算结构</span></span><br><span class="line">    <span class="keyword">int</span> m = X.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n = Y.<span class="built_in">size</span>();<span class="comment">//计算给定序列的长度</span></span><br><span class="line">    <span class="keyword">int</span> maxl = <span class="number">0</span>;<span class="comment">//初始化结果</span></span><br><span class="line">    X = <span class="string">' '</span> + X;</span><br><span class="line">    Y = <span class="string">' '</span> + Y;<span class="comment">//为处理方便，在0位置上插入一个空位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) c[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) c[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (X[i] == Y[j]) c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> c[i][j] = <span class="built_in">max</span>(c[i][j<span class="number">-1</span>], c[i<span class="number">-1</span>][j]);</span><br><span class="line">            maxl = <span class="built_in">max</span>(maxl, c[i][j]);<span class="comment">//更新答案</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">string</span> X, Y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; X &gt;&gt; Y;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, lcs(X,Y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数学解释</p><p>求解最大公共子序列可以分解为子问题：在长度较短的序列上加上一段序列再做判断；</p><p>（1）若两条序列中有一条为0， 则此时的公共子序列为0；</p><p>（2）若两条序列中新加入的元素相等，那最大子序列则可以在$c[i-1][j-1]$的基础上加一；</p><p>（3）若二者不想等，则考虑取$\max(c[i-1][j], c[i][j-1])$;</p><p>对X和Y都做了循环，时间复杂度为$O(nm)$，由于开辟了数组，空间复杂度为$O(nm)$；</p><p><strong>矩阵链乘法</strong>：时间复杂度$O(n^3)$</p><p>对于给定长度为$n$的矩阵链，若想得到其相乘结果，求最少的标量乘法计算次数；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, p[N+<span class="number">1</span>], m[N+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p[i<span class="number">-1</span>], &amp;p[i]);<span class="comment">//存入行、列数目</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//m[i][j]表示从第i个矩阵乘至第j个矩阵的成本，那么在j小于i的情形下的结果不予j考虑；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) m[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对于i,j相等的情况，实际上并没有进行计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; ++l)&#123;<span class="comment">//l表示用于计算的矩阵的个数，从而控制i,j所在的范围</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + l - <span class="number">1</span>;</span><br><span class="line">            m[i][j] = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j - <span class="number">1</span>; ++k)&#123;</span><br><span class="line">                m[i][j] = <span class="built_in">min</span>(m[i][j],m[i][k] + m[k+<span class="number">1</span>][j] + p[i<span class="number">-1</span>]*p[k]*p[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, m[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$m[i][j]$的最小成本就是$m[i][k],m[k+1][j]$的成本加上这两个矩阵的成本，其中$k$是位于$i,j$中的某一数值，可以与$i$相等，但不可以与$j$相等；对$i,j$中所有满足的元素进行遍历，最终求的最小值；但关于$i$和$j$的范围需要控制的；</p><h4 id="第十二章：图"><a href="#第十二章：图" class="headerlink" title="第十二章：图"></a>第十二章：图</h4><p>图的组成：结点（Node）、关系（Edge）；</p><p>图的分类：无向图、有向图、加权无向图、加权有向图；</p><p>图的基本算法：深度优先搜索、广度优先搜索；</p><p><strong>图的表示</strong></p><p>（1）领接表</p><p>每一个顶点对应一个表，表内存储相邻的点编号；</p><p>（2）领接矩阵</p><p>设二维数组为$M$，则$M[i][j]$表示顶点$i$和顶点$j$之间的关系；邻接矩阵呈现右上左下对称形式；</p><p>邻接矩阵可以直接引用边，但需要较大的内存空间且只能记录两个顶点间的一个关系；</p><p><strong>深度优先搜索</strong></p><p>基本思路：尽可能访问相邻顶点，进行递归搜索，搜索完毕后返回至另一相邻点，直至所有顶点都被搜索完毕；</p><p>方法一：递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> WHITE = <span class="number">0</span>;<span class="comment">//白色表示为搜索过</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> GRAY = <span class="number">1</span>;<span class="comment">//灰色表示搜索状态中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BLACK = <span class="number">2</span>;<span class="comment">//黑色表示搜索完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, M[N][N];</span><br><span class="line"><span class="keyword">int</span> color[N], d[N], f[N], tt;<span class="comment">//color用于存储状态，d,f用于存储开始和结束时刻，tt为时钟</span></span><br><span class="line"><span class="keyword">int</span> nt[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//用递归的方法实现深度优先搜索，时间复杂度更高</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_visit</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  color[u] = GRAY;<span class="comment">//当前结点状态改变</span></span><br><span class="line">  d[u] = ++tt;<span class="comment">//记录访问时刻</span></span><br><span class="line">  <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; n; ++v)&#123; <span class="comment">//对周边结点进行搜索</span></span><br><span class="line">    <span class="keyword">if</span> (M[u][v] == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//若没有边，则不许搜索</span></span><br><span class="line">    <span class="keyword">if</span> (color[r] == WHITE) dfs_visit(v); <span class="comment">//深度搜索</span></span><br><span class="line">  &#125;</span><br><span class="line">  color[u] = black;</span><br><span class="line">  f[u] = ++tt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//对状态进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      color[i] = WHITE; </span><br><span class="line">      nt[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; ++u)&#123;</span><br><span class="line">      <span class="keyword">if</span> (color[u] == WHITE) dfs_visit(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; d[i] &lt;&lt; <span class="string">" "</span> &lt;&lt; f[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, k, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="comment">//对矩阵进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">        M[i][j] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将图结构中的边用邻接矩阵存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;k);</span><br><span class="line">      u--;<span class="comment">//以0为起点的修正</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, v);</span><br><span class="line">        v--;<span class="comment">//0起点修正</span></span><br><span class="line">        M[u][v] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0起点修正：顶点从1开始，但计算机数组的存储从0开始，故减去1即可；</span></span><br></pre></td></tr></table></figure><p>方法二：使用栈</p><p>1.将最初访问的顶点压入栈中；<br>2.若栈非空，则访问栈顶，之后若移动至另一点时再压入栈中，如不存在未访问结点，则结束搜索；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用栈实现深度优先搜索，时间复杂度更低</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找相邻结点的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="comment">//判断是否存在一个结点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v = nt[u]; v &lt; n; ++v)&#123;</span><br><span class="line">    nt[u] = v + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (M[u][v]) <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先搜索函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_visit</span><span class="params">(<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) nt[i] = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">  S.push(r);<span class="comment">//将当前结点压入栈中</span></span><br><span class="line">  color[r] = GRAY;</span><br><span class="line">  d[r] = ++tt;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(!S.empty())&#123;</span><br><span class="line">    <span class="keyword">int</span> u = S.top();</span><br><span class="line">    <span class="keyword">int</span> v = next(u);</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(color[r] == WHITE)&#123;</span><br><span class="line">        color[r] = GRAY;</span><br><span class="line">        d[v] = ++tt;<span class="comment">//记录开始访问时刻</span></span><br><span class="line">        S.push(v);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        S.pop();</span><br><span class="line">        color[u] = BLACK;</span><br><span class="line">        f[u] = ++tt;<span class="comment">//记录结束访问时刻</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>广度优先搜索</strong>（从起点开始，按照与起点的<strong>距离</strong>管理）</p><p>1.将起点s放入队列Q中</p><p>2.只要Q不为空，则循环：从Q中取出顶点进行访问，将与u相邻的未访问结点放入Q中，更新距离</p><p>缺点，广度优先搜索中，程序要调查每个顶点是否与其他所有结点相邻，故算法复杂度较高</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INFTY = (<span class="number">1</span>&lt;&lt;<span class="number">21</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, M[N][N];<span class="comment">//顶点数目与图结构</span></span><br><span class="line"><span class="keyword">int</span> d[N];<span class="comment">//距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从起点开始进行访问，度量与起点的距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(s);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) d[i] = INFTY;<span class="comment">//初始化，未判断前，均为无穷远</span></span><br><span class="line">  d[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> u;</span><br><span class="line">  <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">    u = q.front(); </span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; ++v)&#123;</span><br><span class="line">      <span class="keyword">if</span> (M[u][v] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (d[v] != INFTY) <span class="keyword">continue</span>;<span class="comment">//d[v]不为无穷时，说明已经访问过并放入了栈中</span></span><br><span class="line">      d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">      q.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">" "</span>&lt;&lt;  ((d[i] == INFTY) ? (<span class="number">-1</span>) : d[i]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> u, k, v;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">      M[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;k);</span><br><span class="line">    u--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">      v--;</span><br><span class="line">      M[u][v] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bfs(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>连通分量问题（ALDS1_11_D）</strong>：利用广度优先搜索测量距离，只要距离不是无穷，则说明可以到达。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路，使用bfs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INFTY = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, M[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(s);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) d[i] = INFTY;</span><br><span class="line">  d[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> u;</span><br><span class="line">  <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">    u = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; ++v)&#123;</span><br><span class="line">      <span class="keyword">if</span> (M[u][v] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (d[v] != INFTY) <span class="keyword">continue</span>;</span><br><span class="line">      d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">      q.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">      M[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//存入图结构</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line">    M[u][v] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line">    bfs(u);</span><br><span class="line">    <span class="keyword">if</span>(d[v] != INFTY) <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于此题目中的顶点数量过大，故不宜使用邻接矩阵，而采用vector距离邻接表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NIL = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAX];</span><br><span class="line"><span class="keyword">int</span> color[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">  S.push(r);</span><br><span class="line">  color[r] = c;</span><br><span class="line">  <span class="keyword">while</span>(!S.empty())&#123;</span><br><span class="line">    <span class="keyword">int</span> u = S.top();</span><br><span class="line">    s.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">      <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">      <span class="comment">//如果还没有上色，就上色并以此作为结点继续上色</span></span><br><span class="line">      <span class="keyword">if</span> (color[v] == NIL)&#123;</span><br><span class="line">        color[v] = c;</span><br><span class="line">        S.push(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assignColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) color[i] = NIL;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (color[u] == NIL) dfs(u, id++);</span><br><span class="line">    <span class="comment">//以u为起点展开深度优先搜索，并存储颜色，这样可以保持同一棵连通图</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s, t, m, q;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, n, m);</span><br><span class="line">  <span class="comment">//将关系存入邻接表</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s, &amp;t);</span><br><span class="line">    G[s].push_back(t);</span><br><span class="line">    G[t].push_back(s);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  assignColor();</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s, &amp;t);</span><br><span class="line">    <span class="keyword">if</span> (color[s] == color[t]) <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第十三章：加权图"><a href="#第十三章：加权图" class="headerlink" title="第十三章：加权图"></a>第十三章：加权图</h4><p><strong>基本概念</strong></p><p>（1）树：没有环的图；</p><p>（2）图G的生成树：图G的子图，包含了G的所有顶点，在保证是树的前提上保留尽量多的边；</p><p>（3）最小生成树：各边权重值最小的树；</p><p>（4）最短路径：给定顶点$s,d$之间各边权值最小的路径；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1)单源最短路径：求给定顶点到其它所有顶点的最短路径；</span><br><span class="line">(2)全点对间最短路径：求“每一对顶点”之间的最短路径；</span><br></pre></td></tr></table></figure><p>（5）最短路径生成树：给定顶点$s$，包含$s$到图$G$所有顶点最短路径的生成树；</p><p><strong>最小生成树</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 保研ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六学期学习计划（日更）</title>
      <link href="/2020/03/26/%E7%AC%AC%E5%85%AD%E5%AD%A6%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%EF%BC%88%E6%97%A5%E6%9B%B4%EF%BC%89/"/>
      <url>/2020/03/26/%E7%AC%AC%E5%85%AD%E5%AD%A6%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%EF%BC%88%E6%97%A5%E6%9B%B4%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="5月1日"><a href="#5月1日" class="headerlink" title="5月1日"></a>5月1日</h2><p>（1）数据结构与算法分析：第三章</p><p>（2）固体物理作业</p><h2 id="4月21日"><a href="#4月21日" class="headerlink" title="4月21日"></a>4月21日</h2><p>（1）上午一二节：Python玩转数据</p><p>（2）上午三四节：金融微观结构</p><p>（3）中午：原子核物理第六章复习及作业</p><p>（4）下午一二节：大学化学</p><p>（5）下午三四节：固体物理习题课</p><p>（6）晚上一：量子信息课程</p><p>（7）晚上二：leetcode哈希表部分学习+练习</p><h2 id="4月17日"><a href="#4月17日" class="headerlink" title="4月17日"></a>4月17日</h2><p>（1）上午一二节：原子核物理</p><p>（2）上午三四节：机器学习导论</p><p>（3）中午：原子核物理作业</p><p>（4）下午一二节：固体物理</p><p>（5）下午三四节：算法导论</p><p>（6）晚上：算法与数据结构第十三章</p><h2 id="4月14日"><a href="#4月14日" class="headerlink" title="4月14日"></a>4月14日</h2><p>（1）上午一二节：原子核物理；</p><p>（2）上午三四节：算法导论与leetcode；</p><p>（3）中午：固定收益证券；</p><p>（4）下午：大学化学第十二章and作业；</p><p>（5）晚上：量子信息课程；leetcode与算法导论；</p><h2 id="4月13日"><a href="#4月13日" class="headerlink" title="4月13日"></a>4月13日</h2><p>（1）上午一二节：leetcode刷题、复习bfs和dfs</p><p>（2）上午三四节：固体物理</p><p>（3）中午：固定收益证券</p><p>（4）下午一二节：原子核物理视频</p><p>（5）下午三四节：原子核物理作业</p><p>（6）晚上：中金自我介绍、决策树、算法导论-动态规划部分</p><h2 id="4月8日"><a href="#4月8日" class="headerlink" title="4月8日"></a>4月8日</h2><p>（1）上午一二节：大学化学视频、大学化学作业；</p><p>（2）上午三四节：leetcode每日练习与《算法导论——动态规划》</p><p>（3）下午一二节：机器学习第三章</p><p>（4）晚上：lijun zhang论文，leetcode刷题</p><h2 id="4月7日"><a href="#4月7日" class="headerlink" title="4月7日"></a>4月7日</h2><p>（1）上午：leetcode每日练习、算法与数据结构：动态规划、leetcode每日练习</p><p>（2）下午一二节：大学化学课程；</p><p>（3）下午三四节：固体物理习题课；</p><p>（4）晚上：量子信息课程、大学化学作业；</p><h2 id="4月6日"><a href="#4月6日" class="headerlink" title="4月6日"></a>4月6日</h2><p>（1）上午一二节：算法与数据结构、leetcode一题</p><p>（2）上午三四节：固体物理课程视频与复习</p><p>（3）下午一二节：原子核物理课程复习</p><p>（4）下午三四节：在线凸优化复习</p><p>（5）晚上：Leetcode刷题与机器学习基础知识</p><h2 id="3月31日"><a href="#3月31日" class="headerlink" title="3月31日"></a>3月31日</h2><p>（1）上午一二节：算法与数据结构第九章</p><p>（2）上午三四节与中午：leetcode训练习题（至少两道）</p><p>（3）下午一二节：大学化学课堂</p><p>（4）下午三四节：Lijun Zhang论文（COLT-2013）</p><p>（5）晚上一二三节：量子信息原理与应用</p><p>（6）晚上至睡前：完成量子信息整理与作业</p><h2 id="3月30日（完成率：7-8）"><a href="#3月30日（完成率：7-8）" class="headerlink" title="3月30日（完成率：7/8）"></a>3月30日（完成率：7/8）</h2><p>（1）上午一二节：模拟电路实验报告（完成）</p><p>（2）上午三四节：固体物理课堂（完成）</p><p>（3）午休（完成）</p><p>（4）下午一二节：原子核物理课堂（完成）</p><p>（5）下午三四节：固体物理作业（完成）</p><p>（6）晚上：算法与数据结构（第八章完成），leetcode训练（一题），lijunzhang论文（未完成）</p><h2 id="3月26日（完成率：66-）"><a href="#3月26日（完成率：66-）" class="headerlink" title="3月26日（完成率：66%）"></a>3月26日（完成率：66%）</h2><p>（1）早上一二节：数据结构与算法（完成）</p><p>（2）早上三四节：机器学习（完成）</p><p>（3）中午：助理研究项目纠错（完成）</p><p>（4）下午一二节：固体物理（完成）</p><p>（5）下午三四节：学习推荐系统实践</p><p>（6）晚上：大创数据+量子信息</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
